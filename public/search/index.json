[{"content":"ftxui::Component 模块定义了生成交互式组件的逻辑，这些组件可以响应用户发起的事件(鼠标、键盘)。\nftxui::ScreenInteractive 定义了一个渲染组件的主循环。 ftxui::Component 是 ftxui::ComponentBase 的共享指针。后者定义了:\nftxui::ComponentBase::Render() 如何渲染界面 ftxui::ComponentBase::OnEvent() 如何响应事件 ftxui::ComponentBase::Add() 两个组件之间构建父子关系，组件树用于定义如何使用键盘导航。 ftxui::Element 用于渲染单个帧 ftxui::Component 用于渲染动态用户界面 生成多个帧 并在事件发生时更新其状态。\nInput 用于实现用户输入框\n代码 过滤输入 可以使用 ftxui::CatchEvent 过滤输入组件接收到的字符\nstd::string phone_number; Component input = Input(\u0026amp;phone_number, \u0026#34;phone number\u0026#34;); // 过滤掉非数字字符 input |= CatchEvent([\u0026amp;](Event event) { return event.is_character() \u0026amp;\u0026amp; !std::isdigit(event.character()[0]); }); // 过滤掉第10个字符之后的字符 input |= CatchEvent([\u0026amp;](Event event) { return event.is_character() \u0026amp;\u0026amp; phone_number.size() \u0026gt;= 10; }); Menu 定义一个菜单对象，它包含一个条目列表。\n代码 Toggle 一种特殊菜单 条目水平显示\n代码 CheckBox 定义一个复选框(多选框)\n代码 RadioBox 定义一个单选框\n代码 Dropdown 下拉菜单组件\n代码 Slider 滑块组件\n代码 Renderer 通过使用不同的函数来渲染界面装饰另一个组件\nauto inner = [...] auto renderer = Renderer(inner, [\u0026amp;] { return inner-\u0026gt;Render() | border }); 装饰器模式\nauto component = [...] component = component | Renderer([](Element e) { return e | border)) | Renderer(bold) 组件与装饰器组合\nauto component = [...] component = component | border | bold; CatchEvent 在底层组件之前捕获事件\nauto screen = ScreenInteractive::TerminalOutput(); auto renderer = Renderer([] { return text(\u0026#34;My interface\u0026#34;); }); auto component = CatchEvent(renderer, [\u0026amp;](Event event) { if (event == Event::Character(\u0026#39;q\u0026#39;)) { screen.ExitLoopClosure()(); return true; } return false; }); screen.Loop(component); 用作装饰器\ncomponent = component | CatchEvent(handler_1) | CatchEvent(handler_2) | CatchEvent(handler_3) ; Collapsible 对于用户可以切换可见性的视觉元素很有用，本质上这是 ftxui::Checkbox() 和 ftxui::Maybe() 组件的组合\nauto collapsible = Collapsible(\u0026#34;Show more\u0026#34;, inner_element); Maybe 此组件可以通过布尔值或谓词来显示/隐藏任何其它组件\n布尔值示例:\nbool show = true; auto component = Renderer([]{ return \u0026#34;Hello World!\u0026#34;; }); auto maybe_component = Maybe(component, \u0026amp;show) 谓词示例:\nauto component = Renderer([]{ return \u0026#34;Hello World!\u0026#34;; }); auto maybe_component = Maybe(component, [\u0026amp;] { return time \u0026gt; 10; }) 装饰器示例:\ncomponent = component | Maybe(\u0026amp;a_boolean) | Maybe([\u0026amp;] { return time \u0026gt; 10; }) ; Container Horizontal 它水平显示组件列表\nVertical 它垂直显示组件列表\nTab 它接受一个组件列表并只显示其中一个\n垂直列表代码 水平列表代码 ResizableSplit 它定义了两个子组件之间的水平或垂直分隔，其分隔位置是可变的，并可以使用鼠标控制。\n四种分隔方式:\nftxui::ResizableSplitLeft() ftxui::ResizableSplitRight() ftxui::ResizableSplitTop() ftxui::ResizableSplitBottom() 代码 强制一个帧重新绘制 通常 ftxui::ScreenInteractive::Loop() 负责在处理完新的一组事件（例如键盘、鼠标、窗口大小调整等）时绘制新帧。但是，您可能希望对 FTXUI 未知的任意事件做出反应。为此，您必须通过线程使用 ftxui::ScreenInteractive::PostEvent 这是线程安全的发布事件。您将不得不发布事件 ftxui::Event::Custom\n示例\nscreen-\u0026gt;PostEvent(Event::Custom); 如果您不需要处理新事件，可以使用:\nscreen-\u0026gt;RequestAnimationFrame(); 代替\n","date":"2025-09-01T13:50:00+08:00","permalink":"http://localhost:1313/post/programmingtechnology/ftxui-self-study-guide/ftxui-component/","title":"FTXUI Component 模块"},{"content":"该模块定义了一组层级化的 ftxui::Element 。一个元素（Element）可以管理布局，并且能够响应终端尺寸的变化。请注意以下示例，其中该模块被用来通过若干操作符创建一个简单的布局:\n示例\nnamespace ftxui { ... // 定义文档 Element document = vbox({ text(\u0026#34;The window\u0026#34;) | bold | color(Color::Blue), gauge(0.5) text(\u0026#34;The footer\u0026#34;) }); // 添加边框，通过调用 `ftxui::border` 装饰器函数 document = border(document); // 添加另一个边框，使用管道操作符 document = document | border. // 添加另一个边框，使用 |= 管道操作符 document |= border ... } 元素操作列表\n所有元素都已包含在内，可以通过包含对应的头文件来访问:\n#include \u0026lt;ftxui/dom/elements.hpp\u0026gt; // Copyright 2020 Arthur Sonzogni. All rights reserved. // Use of this source code is governed by the MIT license that can be found in // the LICENSE file. #ifndef FTXUI_DOM_ELEMENTS_HPP #define FTXUI_DOM_ELEMENTS_HPP #include \u0026lt;functional\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026#34;ftxui/dom/canvas.hpp\u0026#34; #include \u0026#34;ftxui/dom/direction.hpp\u0026#34; #include \u0026#34;ftxui/dom/flexbox_config.hpp\u0026#34; #include \u0026#34;ftxui/dom/linear_gradient.hpp\u0026#34; #include \u0026#34;ftxui/dom/node.hpp\u0026#34; #include \u0026#34;ftxui/screen/box.hpp\u0026#34; #include \u0026#34;ftxui/screen/color.hpp\u0026#34; #include \u0026#34;ftxui/screen/terminal.hpp\u0026#34; #include \u0026#34;ftxui/util/ref.hpp\u0026#34; namespace ftxui { class Node; using Element = std::shared_ptr\u0026lt;Node\u0026gt;; using Elements = std::vector\u0026lt;Element\u0026gt;; using Decorator = std::function\u0026lt;Element(Element)\u0026gt;; using GraphFunction = std::function\u0026lt;std::vector\u0026lt;int\u0026gt;(int, int)\u0026gt;; /// @brief BorderStyle is an enumeration that represents the different styles /// of borders that can be applied to elements in the terminal UI. /// /// BorderStyle is an enumeration that represents the different styles of /// borders that can be applied to elements in the terminal UI. /// It is used to define the visual appearance of borders around elements, /// such as windows, frames, or separators. /// @ingroup dom enum BorderStyle { LIGHT, DASHED, HEAVY, DOUBLE, ROUNDED, EMPTY, }; // Pipe elements into decorator togethers. // For instance the next lines are equivalents: // -\u0026gt; text(\u0026#34;ftxui\u0026#34;) | bold | underlined // -\u0026gt; underlined(bold(text(\u0026#34;FTXUI\u0026#34;))) Element operator|(Element, Decorator); Element\u0026amp; operator|=(Element\u0026amp;, Decorator); Elements operator|(Elements, Decorator); Decorator operator|(Decorator, Decorator); // --- Widget --- Element text(std::string text); Element vtext(std::string text); Element separator(); Element separatorLight(); Element separatorDashed(); Element separatorHeavy(); Element separatorDouble(); Element separatorEmpty(); Element separatorStyled(BorderStyle); Element separator(Pixel); Element separatorCharacter(std::string); Element separatorHSelector(float left, float right, Color unselected_color, Color selected_color); Element separatorVSelector(float up, float down, Color unselected_color, Color selected_color); Element gauge(float progress); Element gaugeLeft(float progress); Element gaugeRight(float progress); Element gaugeUp(float progress); Element gaugeDown(float progress); Element gaugeDirection(float progress, Direction direction); Element border(Element); Element borderLight(Element); Element borderDashed(Element); Element borderHeavy(Element); Element borderDouble(Element); Element borderRounded(Element); Element borderEmpty(Element); Decorator borderStyled(BorderStyle); Decorator borderStyled(BorderStyle, Color); Decorator borderStyled(Color); Decorator borderWith(const Pixel\u0026amp;); Element window(Element title, Element content, BorderStyle border = ROUNDED); Element spinner(int charset_index, size_t image_index); Element paragraph(const std::string\u0026amp; text); Element paragraphAlignLeft(const std::string\u0026amp; text); Element paragraphAlignRight(const std::string\u0026amp; text); Element paragraphAlignCenter(const std::string\u0026amp; text); Element paragraphAlignJustify(const std::string\u0026amp; text); Element graph(GraphFunction); Element emptyElement(); Element canvas(ConstRef\u0026lt;Canvas\u0026gt;); Element canvas(int width, int height, std::function\u0026lt;void(Canvas\u0026amp;)\u0026gt;); Element canvas(std::function\u0026lt;void(Canvas\u0026amp;)\u0026gt;); // -- Decorator --- Element bold(Element); Element dim(Element); Element italic(Element); Element inverted(Element); Element underlined(Element); Element underlinedDouble(Element); Element blink(Element); Element strikethrough(Element); Decorator color(Color); Decorator bgcolor(Color); Decorator color(const LinearGradient\u0026amp;); Decorator bgcolor(const LinearGradient\u0026amp;); Element color(Color, Element); Element bgcolor(Color, Element); Element color(const LinearGradient\u0026amp;, Element); Element bgcolor(const LinearGradient\u0026amp;, Element); Decorator focusPosition(int x, int y); Decorator focusPositionRelative(float x, float y); Element automerge(Element child); Decorator hyperlink(std::string link); Element hyperlink(std::string link, Element child); Element selectionStyleReset(Element); Decorator selectionColor(Color foreground); Decorator selectionBackgroundColor(Color foreground); Decorator selectionForegroundColor(Color foreground); Decorator selectionStyle(std::function\u0026lt;void(Pixel\u0026amp;)\u0026gt; style); // --- Layout is // Horizontal, Vertical or stacked set of elements. Element hbox(Elements); Element vbox(Elements); Element dbox(Elements); Element flexbox(Elements, FlexboxConfig config = FlexboxConfig()); Element gridbox(std::vector\u0026lt;Elements\u0026gt; lines); Element hflow(Elements); // Helper: default flexbox with row direction. Element vflow(Elements); // Helper: default flexbox with column direction. // -- Flexibility --- // Define how to share the remaining space when not all of it is used inside a // container. Element flex(Element); // Expand/Minimize if possible/needed. Element flex_grow(Element); // Expand element if possible. Element flex_shrink(Element); // Minimize element if needed. Element xflex(Element); // Expand/Minimize if possible/needed on X axis. Element xflex_grow(Element); // Expand element if possible on X axis. Element xflex_shrink(Element); // Minimize element if needed on X axis. Element yflex(Element); // Expand/Minimize if possible/needed on Y axis. Element yflex_grow(Element); // Expand element if possible on Y axis. Element yflex_shrink(Element); // Minimize element if needed on Y axis. Element notflex(Element); // Reset the flex attribute. Element filler(); // A blank expandable element. // -- Size override; enum WidthOrHeight { WIDTH, HEIGHT }; enum Constraint { LESS_THAN, EQUAL, GREATER_THAN }; Decorator size(WidthOrHeight, Constraint, int value); // --- Frame --- // A frame is a scrollable area. The internal area is potentially larger than // the external one. The internal area is scrolled in order to make visible the // focused element. Element frame(Element); Element xframe(Element); Element yframe(Element); Element focus(Element); Element select(Element e); // Deprecated - Alias for focus. // --- Cursor --- // Those are similar to `focus`, but also change the shape of the cursor. Element focusCursorBlock(Element); Element focusCursorBlockBlinking(Element); Element focusCursorBar(Element); Element focusCursorBarBlinking(Element); Element focusCursorUnderline(Element); Element focusCursorUnderlineBlinking(Element); // --- Misc --- Element vscroll_indicator(Element); Element hscroll_indicator(Element); Decorator reflect(Box\u0026amp; box); // Before drawing the |element| clear the pixel below. This is useful in // combinaison with dbox. Element clear_under(Element element); // --- Util -------------------------------------------------------------------- Element hcenter(Element); Element vcenter(Element); Element center(Element); Element align_right(Element); Element nothing(Element element); namespace Dimension { Dimensions Fit(Element\u0026amp;, bool extend_beyond_screen = false); } // namespace Dimension } // namespace ftxui // Make container able to take any number of children as input. #include \u0026#34;ftxui/dom/take_any_args.hpp\u0026#34; // Include old definitions using wstring. #include \u0026#34;ftxui/dom/deprecated.hpp\u0026#34; #endif // FTXUI_DOM_ELEMENTS_HPP Text 最简单且常用的控件，它用来显示文本。\ntext(\u0026#34;我是一段文本\u0026#34;); 我是一段文本 VText 与 ftxui::text 相同，但它是垂直显示的。\nvtext(\u0026#34;HELLO\u0026#34;); H E L L O Paragraph 类似于 ftxui::text 但单词会根据容器的宽度自动换行到多行。\nparagraph(\u0026#34;A very long text\u0026#34;); 详细示例请查阅 官方演示 Paragraph 相关变体演示:\nnamespace ftxui { Element paragraph(std::string text); Element paragraphAlignLeft(std::string text); Element paragraphAlignRight(std::string text); Element paragraphAlignCenter(std::string text); Element paragraphAlignJustify(std::string text); } Border 在元素周围添加边框\nborder(text(\u0026#34;The element\u0026#34;)) 终端输出:\n┌───────────┐ │The element│ └───────────┘ 可以使用管道操作符实现相同的功能:\ntext(\u0026#34;The element\u0026#34;) | border Border 也有不同的样式变体，如下所示:\nnamespace ftxui { Element border(Element); Element borderLight(Element); Element borderHeavy(Element); Element borderDouble(Element); Element borderRounded(Element); Element borderEmpty(Element); Decorator borderStyled(BorderStyle); Decorator borderWith(Pixel); } Window ftxui::window 是一个 ftxui::border 但带有一个额外的标题，要在元素周围添加窗口请将其包装并指定一个字符串作为标题。代码：\nwindow(\u0026#34;The window\u0026#34;, text(\u0026#34;The element\u0026#34;)) ┌The window─┐ │The element│ └───────────┘ Separator 显示一条分割线(垂直/水平)，将容器内容一分为二。\nborder( hbox({ text(\u0026#34;Left\u0026#34;), separator(), text(\u0026#34;Right\u0026#34;) }) ) 终端输出:\n┌────┬─────┐ │left│right│ └────┴─────┘ 其它变体:\nnamespace ftxui { Element separator(void); Element separatorLight(); Element separatorHeavy(); Element separatorDouble(); Element separatorEmpty(); Element separatorStyled(BorderStyle); Element separator(Pixel); Element separatorCharacter(std::string); Element separatorHSelector(float left, float right, Color background, Color foreground); Element separatorVSelector(float up, float down, Color background, Color foreground); } Gauge 一个进度条元素\nborder(gauge(0.5)) 终端输出:\n┌────────────────────────────────────────────────────────────────────────────┐ │██████████████████████████████████████ │ └────────────────────────────────────────────────────────────────────────────┘ Gauges 可以以多种形式显示:\nnamespace { Element gauge(float ratio); Element gaugeLeft(float ratio); Element gaugeRight(float ratio); Element gaugeUp(float ratio); Element gaugeDown(float ratio); Element gaugeDirection(float ratio, GaugeDirection); } Colors 在终端显示彩色文本和彩色背景，FTXUI 支持所有调色板:\nDecorator color(Color); Decorator bgcolor(Color); 调色板 16 Default Black GrayDark GrayLight White Blue BlueLight Cyan CyanLight Green GreenLight Magenta MagentaLight Red RedLight Yellow YellowLight 使用管道操作符使用上述颜色的示例:\ntext(\u0026#34;Blue foreground\u0026#34;) | color(Color::Blue); text(\u0026#34;Blue background\u0026#34;) | bgcolor(Color::Blue); text(\u0026#34;Black on white\u0026#34;) | color(Color::Black) | bgcolor(Color::White); 调色板 256 在支持256色的终端上使用\ntext(\u0026#34;HotPink\u0026#34;) | color(Color::HotPink); TrueColor 在支持 TrueColor 的终端上，您可以直接使用 24 位 RGB 颜色空间\n使用以下构造函数指定颜色的 RGB 或 HSV 值\n有两个构造函数\nftxui::Color::RGB(uint8_t red, uint8_t green, uint8_t blue); ftxui::Color::HSV(uint8_t hue, uint8_t saturation, uint8_t value); LinearGradient FTXUI 支持线性渐变。可以在前景色或背景色上使用。\nDecorator color(const LinearGradient\u0026amp;); Decorator bgcolor(const LinearGradient\u0026amp;); ftxui::LinearGradient 由一个度和颜色停止点列表定义\nauto gradient = LinearGradient() .Angle(45) .AddStop(0.0, Color::Red) .AddStop(0.5, Color::Green) .AddStop(1.0, Color::Blue); 也可以使用简化的构造函数:\nLinearGradient(Color::Red, Color::Blue); LinearGradient(45, Color::Red, Color::Blue); 详细演示 Style 除了彩色文本和彩色背景，还支持许多其它的文本样式，例如: 加粗、倾斜、下划线……\nElement bold(Element); Element italic(Element); Element dim(Element); Element inverted(Element); Element underlined(Element); Element underlinedDouble(Element); Element strikethrough(Element); Element blink(Element); Decorator color(Color); Decorator bgcolor(Color); Decorator colorgrad(LinearGradient); Decorator bgcolorgrad(LinearGradient); 演示 要使用这些效果，只需用想要的样式包装在元素外边:\nunderlined(bold(text(\u0026#34;This text is bold and underlined\u0026#34;))) 或者直接使用管道操作符将其链接到元素上:\ntext(\u0026#34;This text is bold\u0026#34;) | bold | underlined Layout 使元素能够以以下方式进行排列布局:\n水平布局 ftxui::hbox 垂直布局 ftxui::vbox 网格布局 ftxui::gridbox 沿着特定方向换行 ftxui::flexbox 使用 ftxui::hbox ftxui::vbox ftxui::filler 示例:\n其它演示 元素也可以使用 ftxui::flex 装饰器变得更灵活\nhbox({ text(\u0026#34;left\u0026#34;) | border , text(\u0026#34;middle\u0026#34;) | border | flex, text(\u0026#34;right\u0026#34;) | border, }); 终端输出:\n┌────┐┌─────────────────────────────────────────────────────┐┌─────┐ │left││middle ││right│ └────┘└─────────────────────────────────────────────────────┘└─────┘ hbox({ text(\u0026#34;left\u0026#34;) | border , text(\u0026#34;middle\u0026#34;) | border | flex, text(\u0026#34;right\u0026#34;) | border | flex, }); ┌────┐┌───────────────────────────────┐┌───────────────────────────────┐ │left││middle ││right │ └────┘└───────────────────────────────┘└───────────────────────────────┘ Table 能够轻松地将数据格式化为整洁的表格形式\n// Copyright 2020 Arthur Sonzogni. All rights reserved. // Use of this source code is governed by the MIT license that can be found in // the LICENSE file. #include \u0026lt;ftxui/dom/elements.hpp\u0026gt; // for color, Fit, LIGHT, align_right, bold, DOUBLE #include \u0026lt;ftxui/dom/table.hpp\u0026gt; // for Table, TableSelection #include \u0026lt;ftxui/screen/screen.hpp\u0026gt; // for Screen #include \u0026lt;iostream\u0026gt; // for endl, cout, ostream #include \u0026lt;string\u0026gt; // for basic_string, allocator, string #include \u0026lt;vector\u0026gt; // for vector #include \u0026#34;ftxui/dom/node.hpp\u0026#34; // for Render #include \u0026#34;ftxui/screen/color.hpp\u0026#34; // for Color, Color::Blue, Color::Cyan, Color::White, ftxui int main() { using namespace ftxui; auto table = Table({ {\u0026#34;Version\u0026#34;, \u0026#34;Marketing name\u0026#34;, \u0026#34;Release date\u0026#34;, \u0026#34;API level\u0026#34;, \u0026#34;Runtime\u0026#34;}, {\u0026#34;2.3\u0026#34;, \u0026#34;Gingerbread\u0026#34;, \u0026#34;February 9 2011\u0026#34;, \u0026#34;10\u0026#34;, \u0026#34;Dalvik 1.4.0\u0026#34;}, {\u0026#34;4.0\u0026#34;, \u0026#34;Ice Cream Sandwich\u0026#34;, \u0026#34;October 19 2011\u0026#34;, \u0026#34;15\u0026#34;, \u0026#34;Dalvik\u0026#34;}, {\u0026#34;4.1\u0026#34;, \u0026#34;Jelly Bean\u0026#34;, \u0026#34;July 9 2012\u0026#34;, \u0026#34;16\u0026#34;, \u0026#34;Dalvik\u0026#34;}, {\u0026#34;4.2\u0026#34;, \u0026#34;Jelly Bean\u0026#34;, \u0026#34;November 13 2012\u0026#34;, \u0026#34;17\u0026#34;, \u0026#34;Dalvik\u0026#34;}, {\u0026#34;4.3\u0026#34;, \u0026#34;Jelly Bean\u0026#34;, \u0026#34;July 24 2013\u0026#34;, \u0026#34;18\u0026#34;, \u0026#34;Dalvik\u0026#34;}, {\u0026#34;4.4\u0026#34;, \u0026#34;KitKat\u0026#34;, \u0026#34;October 31 2013\u0026#34;, \u0026#34;19\u0026#34;, \u0026#34;Dalvik and ART\u0026#34;}, {\u0026#34;5.0\u0026#34;, \u0026#34;Lollipop\u0026#34;, \u0026#34;November 3 2014\u0026#34;, \u0026#34;21\u0026#34;, \u0026#34;ART\u0026#34;}, {\u0026#34;5.1\u0026#34;, \u0026#34;Lollipop\u0026#34;, \u0026#34;March 9 2015\u0026#34;, \u0026#34;22\u0026#34;, \u0026#34;ART\u0026#34;}, {\u0026#34;6.0\u0026#34;, \u0026#34;Marshmallow\u0026#34;, \u0026#34;October 5 2015\u0026#34;, \u0026#34;23\u0026#34;, \u0026#34;ART\u0026#34;}, {\u0026#34;7.0\u0026#34;, \u0026#34;Nougat\u0026#34;, \u0026#34;August 22 2016\u0026#34;, \u0026#34;24\u0026#34;, \u0026#34;ART\u0026#34;}, {\u0026#34;7.1\u0026#34;, \u0026#34;Nougat\u0026#34;, \u0026#34;October 4 2016\u0026#34;, \u0026#34;25\u0026#34;, \u0026#34;ART\u0026#34;}, {\u0026#34;8.0\u0026#34;, \u0026#34;Oreo\u0026#34;, \u0026#34;August 21 2017\u0026#34;, \u0026#34;26\u0026#34;, \u0026#34;ART\u0026#34;}, {\u0026#34;8.1\u0026#34;, \u0026#34;Oreo\u0026#34;, \u0026#34;December 5 2017\u0026#34;, \u0026#34;27\u0026#34;, \u0026#34;ART\u0026#34;}, {\u0026#34;9\u0026#34;, \u0026#34;Pie\u0026#34;, \u0026#34;August 6 2018\u0026#34;, \u0026#34;28\u0026#34;, \u0026#34;ART\u0026#34;}, {\u0026#34;10\u0026#34;, \u0026#34;10\u0026#34;, \u0026#34;September 3 2019\u0026#34;, \u0026#34;29\u0026#34;, \u0026#34;ART\u0026#34;}, {\u0026#34;11\u0026#34;, \u0026#34;11\u0026#34;, \u0026#34;September 8 2020\u0026#34;, \u0026#34;30\u0026#34;, \u0026#34;ART\u0026#34;}, }); table.SelectAll().Border(LIGHT); // Add border around the first column. table.SelectColumn(0).Border(LIGHT); // Make first row bold with a double border. table.SelectRow(0).Decorate(bold); table.SelectRow(0).SeparatorVertical(LIGHT); table.SelectRow(0).Border(DOUBLE); // Align right the \u0026#34;Release date\u0026#34; column. table.SelectColumn(2).DecorateCells(align_right); // Select row from the second to the last. auto content = table.SelectRows(1, -1); // Alternate in between 3 colors. content.DecorateCellsAlternateRow(color(Color::Blue), 3, 0); content.DecorateCellsAlternateRow(color(Color::Cyan), 3, 1); content.DecorateCellsAlternateRow(color(Color::White), 3, 2); auto document = table.Render(); auto screen = Screen::Create(Dimension::Fit(document, /*extend_beyond_screen=*/true)); Render(screen, document); screen.Print(); std::cout \u0026lt;\u0026lt; std::endl; return 0; } Canvas 可以在 ftxui::Canvas 上进行绘图\n详细 API ftxui/dom/canvas ","date":"2025-08-30T17:46:00+08:00","permalink":"http://localhost:1313/post/programmingtechnology/ftxui-self-study-guide/ftxui-dom/","title":"FTXUI Dom 模块"},{"content":"ftxui::screen 模块是 FTXUI 框架的底层核心，它可以独立使用，但主要设计用于与 ftxui::dom 和 ftxui::component 模块一起使用\nFTXUI::Screen ftxui::Screen 类表示一个二维的样式化字符网格，可以渲染到终端，它提供了创建屏幕，访问像素和渲染元素的方法。\n可以使用ftxui::Screen::PixelAt 函数来访问屏幕的指定单元格，该函数会返回指定坐标处的像素引用。\n示例\n#include \u0026lt;ftxui/screen/screen.hpp\u0026gt; #include \u0026lt;ftxui/screen/color.hpp\u0026gt; void main() { auto screen = ftxui::Screen::Create( ftxui::Dimension::Full(), // 最大宽度 ftxui::Dimension::Fixed(10) // 固定高度 ); // 访问 (10, 5) 位置的像素 auto\u0026amp; pixel = screen.PixelAt(10, 5); // 设置像素属性 pixel.character = U\u0026#39;X\u0026#39;; pixel.foreground_color = ftxui::Color::Red; pixel.background_color = ftxui::Color::RGB(0, 255, 0); pixel.bold = true; // 设置粗体样式 screen.Print(); // 将平面打印到终端 } 如果坐标超出范围将会返回一个虚拟像素\n屏幕可以使用 ftxui::Screen::Print() 打印到终端，或者使用 ftxui::Screen::ToString() 转换为 std::string 然后输出到终端。\nPrint\nauto screen = ...; screen.Print(); ToString\nauto screen = ...; std::cout \u0026lt;\u0026lt; screen.ToString(); 示例\nauto screen = ...; while(true) { // 绘图操作 ... // 将屏幕打印到终端，重置光标位置和屏幕内容 std::cout \u0026lt;\u0026lt; screen.ToString(); std::cout \u0026lt;\u0026lt; screen.ResetCursorPosition(/*clear=*/true); std::cout \u0026lt;\u0026lt; std::flush; // 暂停一下以控制屏幕刷新率 std::this_thread::sleep_for(std::chrono::milliseconds(100)); } FTXUI::Dimension ftxui::Dimension 工具控制屏幕尺寸\nDimension::Full() 使用屏幕的宽度或高度 Dimension::Fit() 调整大小以适应渲染的 ftxui::Element Dimension::Fixed() 精确使用列或行 这些值将传递给 ftxui::Screen::Create()\nftxui::Screen::Create() 提供了两个重载\nScreen::Create(Dimension) 将宽高设置为相同类型的维度 Screen::Create(Dimension Width, Dimension Heighe) 允许按轴进行不同的控制。 auto screen = ftxui::Screen::Create( ftxui::Dimension::Full(), // 宽度 ftxui::Dimension::Fixed(10) // 高度 ); 创建后渲染一个元素并打印结果\nftxui::Render(screen, element); screen.Print(); FTXUI::Pixel 屏幕网格中的每一个单元格都是一个 ftxui::Pixel 它包含了:\nUnicode CodePoint (码点) character (存储要显示的单个字符) ftxui::Color foreground_color (前景颜色) background_color (背景颜色) Booleans 样式修饰 blink (闪烁) bold\t(粗体) dim\t(暗淡) italic\t(斜体) inverted\t(反色) underlined\t(下划线) underlined_double\t(双下划线) strikethrough\t(删除线) auto screen = ftxui::Screen::Create( ftxui::Dimension::Fixed(5), ftxui::Dimension::Fixed(5), ); auto\u0026amp; pixel = screen.PixelAt(3, 3); pixel.character = U\u0026#39;X\u0026#39;; pixel.bold = true; pixel.foreground_color = ftxui::Color::Red; pixel.background_color = ftxui::Color::RGB(0, 255, 0); screen.Print(); PixelAt(x, y) 执行边界检查并返回指定坐标处像素的引用。如果超出边界，则返回一个虚拟像素引用。\n屏幕中的每个单元格都是一个 ftxui::Pixel。您可以使用以下方法修改它们:\nauto\u0026amp; pixel = screen.PixelAt(x, y); pixel.character = U\u0026#39;X\u0026#39;; pixel.bold = true; pixel.foreground_color = Color::Red; FTXUI::Color ftxui::Color 类用于定义每个 ftxui::Pixel 的前景色和背景色。\n它支持各种颜色空间和预定义调色板。如果终端不支持请求的颜色，FTXUI 将动态回退到终端中最接近的可用颜色。\n颜色空间\n默认: ftxui::Color::Default 终端默认颜色 16色 调色板 ftxui::Color::Black ftxui::Color::Red …… 256色 调色板 ftxui::Color::Chartreuse1 ftxui::Color::DarkViolet 真彩色 ftxui::Color::RGB(uint8_t red, uint8_t green, uint8_t blue) ftxui::Color::HSV(uint8_t h, uint8_t s, uint8_t v) ","date":"2025-08-27T21:35:00+08:00","permalink":"http://localhost:1313/post/programmingtechnology/ftxui-self-study-guide/ftxui-screen/","title":"FTXUI Screen 模块"},{"content":"FTXUI 可以使用多种构建系统和包管理器集成到您的项目中\n所支持的方式 CMake Bazel VcPkg Debian/Ubuntu CMake 使用 CMake 的三种集成 FTXUI 方式\n使用 FetchContent 这种方式会在编译时自动下载 FTXUI，不需要在系统上安装\ninclude(FetchContent) FetchContent_Declare(ftxui GIT_REPOSITORY https://github.com/ArthurSonzogni/FTXUI GIT_TAG v6.1.9 # Replace with a version, tag, or commit hash ) FetchContent_MakeAvailable(ftxui) add_executable(main main.cpp) target_link_libraries(main PRIVATE ftxui::screen PRIVATE ftxui::dom PRIVATE ftxui::component ) 使用 find_package 如果 FTXUI 已系统上安装或通过包管理器（例如 VcPkg 或 Conan）安装，您可以使用此方式\nfind_package(ftxui REQUIRED) add_executable(main main.cpp) target_link_libraries(main PRIVATE ftxui::screen PRIVATE ftxui::dom PRIVATE ftxui::component ) 使用 git submodule 将 FTXUI 添加为 Git 子模块，使其成为您仓库的一部分\ngit submodule add https://github.com/ArthurSonzogni/FTXUI external/ftxui git submodule update --init --recursive 当克隆一个已经包含 FTXUI 作为子模块的仓库时，请确保使用以下命令获取子模块\ngit clone --recurse-submodules \u0026lt;your-repo\u0026gt; # Or, if already cloned: git submodule update --init --recursive 然后在您的 CMakeLists.txt 中添加\nadd_subdirectory(external/ftxui) add_executable(main main.cpp) target_link_libraries(main PRIVATE ftxui::screen PRIVATE ftxui::dom PRIVATE ftxui::component ) 可选 CMake 选项 FTXUI 支持以下 CMake 选项\n选项 描述 默认 FTXUI_BUILD_EXAMPLES 构建捆绑示例 OFF FTXUI_BUILD_DOCS 构建文档 OFF FTXUI_BUILD_TESTS 启用测试 OFF FTXUI_ENABLE_INSTALL 生成安装目标 OFF FTXUI_MICROSOFT_TERMINAL_FALLBACK 改进 Windows 兼容性 ON/OFF 如果要启用一个选项:\ncmake -DFTXUI_BUILD_EXAMPLES=ON .. Bazel FTXUI 可以使用 Bazel 和 BzlMod 集成到您的项目中，该库已在 Bazel Central Registry 中注册\nMODULE.Bzael bazel_dep(name = \u0026#34;ftxui\u0026#34;, version = \u0026#34;6.1.9\u0026#34;) BUILD.Bazel cc_binary( name = \u0026#34;main\u0026#34;, srcs = [\u0026#34;main.cpp\u0026#34;], deps = [ \u0026#34;@ftxui//:component\u0026#34;, \u0026#34;@ftxui//:dom\u0026#34;, \u0026#34;@ftxui//:screen\u0026#34;, ], ) VcPkg 要在 VcPkg 中使用 FTXUI 库，你可以将以下内容稍作修改后添加到你的 VcPkg.Json 中:\n{ \u0026#34;name\u0026#34;: \u0026#34;your-project\u0026#34;, \u0026#34;version-string\u0026#34;: \u0026#34;0.1.0\u0026#34;, \u0026#34;dependencies\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;ftxui\u0026#34;, \u0026#34;version\u0026gt;=\u0026#34;: \u0026#34;6.1.9\u0026#34; } ] } 使用 VcPkg 安装 FTXUI vcpkg install --triplet x64-linux # 或 x64-windows / arm64-osx 等. 配置构建系统 如果您正在使用 CMake，您可以在 CMakeLists.txt 中使用以下内容:\nCMakeLists.txt\ncmake_minimum_required(VERSION 3.15) project(my_project) # Make sure vcpkg toolchain file is passed at configure time find_package(ftxui CONFIG REQUIRED) add_executable(main main.cpp) target_link_libraries(main PRIVATE ftxui::screen PRIVATE ftxui::dom PRIVATE ftxui::component ) Main.CPP\n#include \u0026lt;ftxui/component/screen_interactive.hpp\u0026gt; #include \u0026lt;ftxui/component/component.hpp\u0026gt; #include \u0026lt;ftxui/component/component_options.hpp\u0026gt; int main() { using namespace ftxui; auto screen = ScreenInteractive::TerminalOutput(); auto button = Button(\u0026#34;Click me\u0026#34;, [] { std::cout \u0026lt;\u0026lt; \u0026#34;Clicked!\\n\u0026#34;; }); screen.Loop(button); } 配置并构建项目\ncmake -B build -S . -DCMAKE_TOOLCHAIN_FILE=/path/to/vcpkg/scripts/buildsystems/vcpkg.cmake cmake --build build ./build/main Debian/Ubuntu 在终端中使用以下命令进行安装\nsudo apt-get install libftxui-dev 安装后可将以下内容添加到 CMakeLists.txt 中:\nfind_package(ftxui REQUIRED) add_executable(main main.cpp) target_link_libraries(main PRIVATE ftxui::screen PRIVATE ftxui::dom PRIVATE ftxui::component ) ","date":"2025-08-27T20:30:00+08:00","permalink":"http://localhost:1313/post/programmingtechnology/ftxui-self-study-guide/ftxui-installation/","title":"FTXUI 安装"},{"content":"\nFTXUI 是一个极具特色的跨平台 C++ TUI（Terminal User Interface，终端用户界面）界面库，专门用于打造基于终端的用户界面。\n函数式风格 设计灵感源于 “Building Reactive Terminal Interfaces in C++” 和 React，采用函数式风格进行构建。这种风格使得代码逻辑更加清晰，易于理解和维护。开发者可以像搭建积木一样，通过组合不同的函数来构建复杂的用户界面，大大提高了开发效率 无第三方依赖 该框架最大的优势之一就是不依赖任何第三方库。这意味着在项目开发过程中，无需担心因第三方库的版本兼容性问题而导致的各种错误，也减少了项目的复杂度和维护成本。开发者可以更加专注于业务逻辑的实现，快速搭建出稳定可靠的终端应用。 跨平台 FTXUI 支持多种主流操作系统，包括 Linux、MacOS、Windows 以及 WebAssembly。无论是在服务器端的 Linux 环境中，还是在个人电脑的 Windows 或 MacOS 系统上，甚至是在 Web 端通过 WebAssembly 运行，FTXUI 都能保证应用的一致性和稳定性。这使得开发者能够轻松将应用部署到不同的平台，满足更广泛用户的需求。 语法简洁 通过操作符重载（如管道符 |），可以链式地为界面元素添加样式和布局属性，代码表达力强。 支持鼠标和键盘操作 内置对鼠标和键盘事件的支持，可以轻松实现点击、拖拽、滚动等交互操作。 支持 UTF-8 和 全角字符 支持 UTF-8 编码和全角字符，确保在不同语言环境下都能正确显示。 支持动画和绘图 支持创建流畅的动画效果和基于字符的图形绘制。 示例 #include \u0026lt;ftxui/dom/elements.hpp\u0026gt; #include \u0026lt;ftxui/screen/screen.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { using namespace ftxui; // 创建一个包含三个文本元素的文档 Element document = hbox({ text(\u0026#34;left\u0026#34;) | border, text(\u0026#34;middle\u0026#34;) | border | flex, text(\u0026#34;right\u0026#34;) | border, }); // 创建一个屏幕，宽度全屏，高度自适应 auto screen = Screen::Create( Dimension::Full(), // 宽度 Dimension::Fit(document) // 高度 ); // 将文档渲染到屏幕上 Render(screen, document); // 将屏幕打印到控制台 screen.Print(); } 预期输出内容:\n┌────┐┌────────────────────────────────────┐┌─────┐ │left││middle ││right│ └────┘└────────────────────────────────────┘└─────┘ ","date":"2025-08-27T20:00:00+08:00","permalink":"http://localhost:1313/post/programmingtechnology/ftxui-self-study-guide/ftxui-introduction/","title":"FTXUI 介绍"},{"content":"项目背景 在许多工作与学习场景中，高质量的PPT模板是提升演示文稿专业度的关键资源。“优品PPT”（ypppt.com）是一个提供大量免费、优质PPT模板的公开网站。然而，当需要批量获取或按分类归档这些资源时，手动下载的方式效率低下且过程繁琐。\n为了解决这一痛点，本文将通过一个完整的实战项目，演示如何利用Python构建一个自动化爬虫，实现对该网站PPT模板的批量下载和分类归档。\n需求分析与目标设定 在编码之前，首先需要明确项目的核心需求和预期目标。一个健壮的爬虫脚本应具备以下功能：\n分类自动发现：动态抓取网站的所有模板分类，避免因网站结构更新导致脚本失效。 分页智能遍历：准确探测每个分类下的总页数，确保数据抓取的完整性。 深度链接解析：模拟用户操作，从列表页 -\u0026gt; 详情页 -\u0026gt; 下载页，最终定位到文件的真实下载地址。 自动化下载与归档：将文件下载至本地，并依据其分类和原始标题进行结构化存储。 良好的交互性：提供命令行接口（CLI），允许用户选择目标分类和下载范围。 基础反爬应对：通过设置User-Agent和随机延时，降低被目标网站屏蔽的风险，并能妥善处理百度网盘等特殊链接。 技术栈选型 针对上述需求，我们选择一套成熟且高效的Python库组合：\nrequests: 业界标准的HTTP库，用于与服务器进行网络通信，获取网页HTML。 BeautifulSoup4: 强大的HTML/XML解析库，能够轻松地从复杂的文档树中提取所需数据。 os: Python内置库，用于处理文件系统操作，如创建目录。 re: Python内置的正则表达式库，用于从非结构化文本中匹配和提取特定模式的数据（如网盘提取码）。 核心实现逻辑解析 爬虫的执行流程遵循一个清晰的逻辑链条。下面对各关键步骤的函数实现进行分析。\n1. 发现并提取全部分类 (get_ppt_categories) 爬虫的入口点是获取所有可爬取的目标范围。通过分析模板主页 (/moban/) 的DOM结构，可以定位到包含分类信息的导航菜单，并从中提取所有分类的名称和URL。\n# 实现思路： # 1. 向目标URL发送GET请求。 # 2. 使用BeautifulSoup解析响应的HTML。 # 3. 通过CSS选择器 `div.menu a` 精准定位到所有分类的\u0026lt;a\u0026gt;标签。 # 4. 遍历标签列表，提取文本内容（分类名）和`href`属性（URL），并进行有效性过滤，最终存入字典。 def get_ppt_categories(): # ... 源码略 ... 2. 动态探测分类的总页数 (get_total_pages) 为了实现完整抓取，必须预先知道每个分类下列表页的总数。一种稳健的策略是模拟用户翻页行为：持续请求下一页，直到出现“下一页”按钮消失或服务器返回404状态码为止。\n关键细节：通过开发者工具分析发现，该站点的分页URL模式为 list-{page}.html。在代码中正确构造此URL是探测成功的关键。\n# 实现思路： # 1. 初始化页码为1，进入一个无限循环。 # 2. 根据当前页码构造URL并发起请求。 # 3. 检查HTTP状态码，若为404则表明已超出最大页数，终止循环。 # 4. 解析页面，查找文本为“下一页”的\u0026lt;a\u0026gt;标签。若不存在，同样终止循环。 # 5. 若存在，则页码加一，并加入一个短暂的随机延时，继续下一次探测。 def get_total_pages(category_url): # ... 源码略 ... 3. 抓取列表页中的详情页URL (get_ppt_list_from_category) 在确定了页数范围后，即可遍历所有列表页，提取其中每个PPT条目指向详情页的URL。\n# 实现思路： # 1. 循环遍历指定的页数。 # 2. 访问每个列表页的URL。 # 3. 使用CSS选择器 `ul.posts.clear \u0026gt; li \u0026gt; a.p-title` 提取所有详情页的链接。 # 4. 将提取到的URL添加到一个全局列表中。 def get_ppt_list_from_category(category_url, max_pages): # ... 源码略 ... 4. 解析并下载最终文件 (download_ppt_file) 这是整个流程的终点。此函数负责完成从详情页到最终文件下载的完整链路。\n该过程涉及两次页面跳转：首先从详情页找到下载页的链接，再从下载页解析出文件的直接下载地址（Direct Link）。\n# 实现思路： # 1. 访问下载页URL，解析HTML。 # 2. 提取页面H1标签作为文件名，并找到最终文件所在的\u0026lt;a\u0026gt;标签。 # 3. **特殊情况处理**：检查链接中是否包含 \u0026#34;pan.baidu.com\u0026#34;。如果是，则使用正则表达式搜索页面文本中的“提取码”，并输出提示信息，不执行下载。 # 4. **常规下载**：对于直链，使用 `requests.get(stream=True)` 发起流式下载请求。 # 5. 清理文件名中的非法字符，并以二进制块（chunk）的形式将文件内容写入本地磁盘。 def download_ppt_file(download_page_url, save_folder): # ... 源码略 ... 使用说明 环境配置：确保已安装Python 3，并通过pip安装必要的依赖库： pip install requests beautifulsoup4 代码保存：将附录中的完整源码保存为 .py 文件，例如 ypppt_spider.py。 脚本执行：在终端中运行该脚本： python ypppt_spider.py 交互式操作：根据终端输出的提示，依次输入目标分类的编号和希望下载的页数（或输入all下载全部）。脚本将自动执行后续任务。 完整源码 import os import time import requests from bs4 import BeautifulSoup import random import re # --- 全局配置 --- BASE_URL = \u0026#34;https://www.ypppt.com\u0026#34; SAVE_DIR = \u0026#34;PPT_Downloads_Perfect\u0026#34; HEADERS = { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64 ) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36\u0026#39; } # ============================================================================== # 函数区: 修复分页URL格式问题 # ============================================================================== def get_ppt_categories(): \u0026#34;\u0026#34;\u0026#34;从模板主页 /moban/ 获取所有分类\u0026#34;\u0026#34;\u0026#34; print(\u0026#34;正在从模板主页探测全部分类目录...\u0026#34;) try: response = requests.get(f\u0026#34;{BASE_URL}/moban/\u0026#34;, headers=HEADERS) response.raise_for_status() response.encoding = \u0026#39;utf-8\u0026#39; soup = BeautifulSoup(response.text, \u0026#39;html.parser\u0026#39;) category_links = soup.select(\u0026#39;div.menu a\u0026#39;) if not category_links: print(\u0026#34;错误：在模板主页未能探测到任何分类链接。\u0026#34;) return None categories = {} for link in category_links: name = link.text.strip() href = link.get(\u0026#39;href\u0026#39;, \u0026#39;\u0026#39;) # 过滤有效分类链接 if name and href and \u0026#39;/moban/\u0026#39; in href and not link.has_attr(\u0026#39;style\u0026#39;): categories[name] = href print(f\u0026#34;✓ 全部分类目录探测成功！共找到 {len(categories)} 个分类。\u0026#34;) return categories except Exception as e: print(f\u0026#34;错误：访问模板主页失败 - {e}\u0026#34;) return None def get_total_pages(category_url): \u0026#34;\u0026#34;\u0026#34;修复分页URL格式，使用连字符而非下划线\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34; - 正在探测分类 “{category_url}” 的总页数...\u0026#34;) total_pages = 1 base_url = f\u0026#34;{BASE_URL}{category_url}\u0026#34;.rstrip(\u0026#39;/\u0026#39;) while True: # 关键修复：分页URL使用连字符 \u0026#34;list-{page}.html\u0026#34; 而非下划线 current_url = base_url if total_pages == 1 else f\u0026#34;{base_url}/list-{total_pages}.html\u0026#34; print(f\u0026#34; 探测第{total_pages}页: {current_url}\u0026#34;) # 调试输出当前URL try: response = requests.get(current_url, headers=HEADERS, timeout=10) print(f\u0026#34; 响应状态: {response.status_code}\u0026#34;) # 显示响应状态码 if response.status_code == 404: print(f\u0026#34; 第{total_pages}页不存在，停止探测\u0026#34;) break response.raise_for_status() response.encoding = \u0026#39;utf-8\u0026#39; soup = BeautifulSoup(response.text, \u0026#39;html.parser\u0026#39;) # 根据页面源码优化下一页按钮识别 next_page = soup.find(\u0026#39;a\u0026#39;, string=\u0026#39;下一页\u0026#39;) if not next_page: print(f\u0026#34; 未找到下一页按钮，当前页{total_pages}为最后一页\u0026#34;) break # 验证下一页URL是否有效（防止虚假按钮） next_page_url = next_page.get(\u0026#39;href\u0026#39;, \u0026#39;\u0026#39;) if not next_page_url or \u0026#39;list-\u0026#39; not in next_page_url: print(f\u0026#34; 下一页链接无效，停止探测\u0026#34;) break total_pages += 1 time.sleep(random.uniform(1, 1.5)) # 延迟避免反爬 except Exception as e: print(f\u0026#34; 探测第{total_pages}页出错: {e}，停止探测\u0026#34;) break print(f\u0026#34; - ✓ 探测到总页数为: {total_pages}\u0026#34;) return total_pages def get_ppt_list_from_category(category_url, max_pages): \u0026#34;\u0026#34;\u0026#34;修复列表页URL格式，匹配网站实际分页\u0026#34;\u0026#34;\u0026#34; all_detail_urls = [] for page_num in range(1, max_pages + 1): base_cat_url = category_url.rstrip(\u0026#39;/\u0026#39;) # 修复列表页URL格式：使用连字符 list_url = f\u0026#34;{BASE_URL}{base_cat_url}\u0026#34; if page_num == 1 else f\u0026#34;{BASE_URL}{base_cat_url}/list-{page_num}.html\u0026#34; print(f\u0026#34; - 正在分析第 {page_num}/{max_pages} 页: {list_url}\u0026#34;) try: response = requests.get(list_url, headers=HEADERS) if response.status_code == 404: print(\u0026#34; - 提示: 页面不存在，已到达最后一页。\u0026#34;) break response.raise_for_status() response.encoding = \u0026#39;utf-8\u0026#39; soup = BeautifulSoup(response.text, \u0026#39;html.parser\u0026#39;) ppt_links = soup.select(\u0026#39;ul.posts.clear \u0026gt; li \u0026gt; a.p-title\u0026#39;) if not ppt_links: print(\u0026#34; - 提示: 此页未找到PPT链接，已到达最后一页。\u0026#34;) break all_detail_urls.extend([link[\u0026#39;href\u0026#39;] for link in ppt_links]) time.sleep(random.uniform(0.5, 1.5)) except Exception as e: print(f\u0026#34; - 错误: 分析列表页 {list_url} 时出错 - {e}\u0026#34;) break return all_detail_urls def get_download_page_url(detail_page_url): try: full_url = f\u0026#34;{BASE_URL}{detail_page_url}\u0026#34; response = requests.get(full_url, headers=HEADERS) response.raise_for_status() response.encoding = \u0026#39;utf-8\u0026#39; soup = BeautifulSoup(response.text, \u0026#39;html.parser\u0026#39;) down_button = soup.select_one(\u0026#39;a.down-button\u0026#39;) return down_button[\u0026#39;href\u0026#39;] if down_button and down_button.has_attr(\u0026#39;href\u0026#39;) else None except Exception as e: print(f\u0026#34; - 错误: 访问详情页 {full_url} 时出错 - {e}\u0026#34;) return None def download_ppt_file(download_page_url, save_folder): try: full_url = f\u0026#34;{BASE_URL}{download_page_url}\u0026#34; response = requests.get(full_url, headers=HEADERS) response.raise_for_status() response.encoding = \u0026#39;utf-8\u0026#39; soup = BeautifulSoup(response.text, \u0026#39;html.parser\u0026#39;) title = (soup.select_one(\u0026#39;div.de \u0026gt; h1\u0026#39;) or soup.new_tag(\u0026#39;h1\u0026#39;)).text.strip().replace(\u0026#39; - 下载页\u0026#39;, \u0026#39;\u0026#39;) or f\u0026#34;ppt_{random.randint(1000, 9999)}\u0026#34; final_link_tag = soup.select_one(\u0026#39;ul.down.clear \u0026gt; li \u0026gt; a\u0026#39;) if not final_link_tag or not final_link_tag.has_attr(\u0026#39;href\u0026#39;): print(f\u0026#34; - 警告：在下载页 {full_url} 未找到最终下载链接。\u0026#34;) return file_url = final_link_tag[\u0026#39;href\u0026#39;] if \u0026#34;pan.baidu.com\u0026#34; in file_url: page_text = soup.get_text() match = re.search(r\u0026#39;提取码\\s*[:：]\\s*([a-zA-Z0-9]{4})\u0026#39;, page_text) pass_code = match.group(1) if match else \u0026#34;未找到\u0026#34; print(f\u0026#34; - 提示：检测到百度网盘资源，请手动下载。\u0026#34;) print(f\u0026#34; - 标题: {title}\\n - 地址: {file_url}\\n - 提取码: {pass_code}\u0026#34;) return print(f\u0026#34; ● 正在下载：{title}\u0026#34;) file_response = requests.get(file_url, headers=HEADERS, stream=True) file_response.raise_for_status() file_name = f\u0026#34;{title}.zip\u0026#34; file_name = re.sub(r\u0026#39;[\\\\/*?:\u0026#34;\u0026lt;\u0026gt;|]\u0026#39;, \u0026#34;\u0026#34;, file_name) save_path = os.path.join(save_folder, file_name) with open(save_path, \u0026#39;wb\u0026#39;) as f: for chunk in file_response.iter_content(chunk_size=8192): f.write(chunk) print(f\u0026#34; ✓ 下载完成，已保存至: {save_path}\u0026#34;) except Exception as e: print(f\u0026#34; - 错误：下载文件时失败 - {e}\u0026#34;) # ============================================================================== # 主程序区 # ============================================================================== if __name__ == \u0026#34;__main__\u0026#34;: categories = get_ppt_categories() if not categories: exit() print(\u0026#34;\\n--- 请选择您要下载的PPT分类 ---\u0026#34;) cat_list = list(categories.items()) for i, (name, url) in enumerate(cat_list): print(f\u0026#34; [{i+1}] {name}\u0026#34;) while True: try: choice = int(input(\u0026#34;\\n请输入分类编号: \u0026#34;).strip()) if 1 \u0026lt;= choice \u0026lt;= len(cat_list): selected_index = choice - 1 break else: print(\u0026#34;输入编号超出范围，请重新输入。\u0026#34;) except ValueError: print(\u0026#34;输入无效，请输入一个数字编号。\u0026#34;) cat_name, cat_url = cat_list[selected_index] # 自动探测总页数（已修复URL格式问题） total_pages = get_total_pages(cat_url) while True: try: page_choice_str = input(f\u0026#34;请输入您想下载的页数 (输入 \u0026#39;all\u0026#39; 下载全部 {total_pages} 页，或输入具体数字): \u0026#34;).strip().lower() if page_choice_str == \u0026#39;all\u0026#39;: pages_to_scrape = total_pages break pages_to_scrape = int(page_choice_str) if 0 \u0026lt; pages_to_scrape \u0026lt;= total_pages: break else: print(f\u0026#34;页数必须在 1 到 {total_pages} 之间。\u0026#34;) except ValueError: print(\u0026#34;输入无效，请输入 \u0026#39;all\u0026#39; 或一个数字。\u0026#34;) if not os.path.exists(SAVE_DIR): os.makedirs(SAVE_DIR) category_folder = os.path.join(SAVE_DIR, cat_name) if not os.path.exists(category_folder): os.makedirs(category_folder) print(f\u0026#34;\\n{\u0026#39;=\u0026#39;*20} 开始下载分类: “{cat_name}” (共 {pages_to_scrape} 页) {\u0026#39;=\u0026#39;*20}\u0026#34;) detail_page_urls = get_ppt_list_from_category(cat_url, pages_to_scrape) if not detail_page_urls: print(\u0026#34;未能从此分类获取到任何PPT列表。\u0026#34;) else: total_count = len(detail_page_urls) print(f\u0026#34;\\n成功获取到 {total_count} 个PPT，开始逐一处理...\u0026#34;) for i, detail_url in enumerate(detail_page_urls): print(f\u0026#34;\\n--- 处理第 {i+1}/{total_count} 个PPT: {detail_url} ---\u0026#34;) download_page_url = get_download_page_url(detail_url) if download_page_url: download_ppt_file(download_page_url, category_folder) else: print(f\u0026#34; - 警告: 未能从 {detail_url} 获取到下载页面链接。\u0026#34;) sleep_time = random.uniform(1, 2) print(f\u0026#34; ...等待 {sleep_time:.2f} 秒...\u0026#34;) time.sleep(sleep_time) print(f\u0026#34;\\n{\u0026#39;=\u0026#39;*20} “{cat_name}” 分类下载任务已完成！ {\u0026#39;=\u0026#39;*20}\u0026#34;) print(f\u0026#34;所有文件已保存在 “{os.path.abspath(SAVE_DIR)}” 文件夹中。\u0026#34;) print(\u0026#34;\\n--- 解压提示 ---\\n如果解压后的文件名出现乱码，请尝试使用命令: unzip -O GBK \u0026#39;文件名.zip\u0026#39;\u0026#34;) ","date":"2025-08-25T18:19:08+08:00","permalink":"http://localhost:1313/post/programmingtechnology/opensourcescripts/premiumproductsppt/","title":"[爬虫脚本] 基于Python的网站爬虫实战：全自动下载优品PPT模板"},{"content":"什么是 Emacs Emacs 是一个功能极其强大的、可扩展的文本编辑器。\nEmacs诞生于1970年代，由著名的计算机科学家理查德·斯托曼（Richard Stallman）创造。它是自由软件运动的标志性项目之一，对后来的很多软件开发理念产生了深远影响。\n它内置了一种名为 Emacs Lisp 的编程语言（是Lisp语言的一种方言）。用户可以通过编写 Emacs Lisp 代码来修改编辑器的任何行为，从简单的颜色主题、快捷键，到增加全新的功能模块。这意味着你可以把 Emacs 打造成任何你想要的样子。\n由于其强大的扩展性，Emacs 的功能早已超越了编辑文本的范畴。通过各种插件（Packages），你可以在 Emacs 内部完成几乎所有日常的电脑操作，例如：\n编程：支持几乎所有编程语言，提供语法高亮、代码补全、调试等功能。 收发邮件：使用 mu4e 或 notmuch 等插件。 文件管理：使用 dired 模式，可以像在文件管理器中一样操作文件和目录。 日程管理和笔记：使用强大的 org-mode，这是 Emacs 的“杀手级应用”，可以用来写文档、做笔记、管理待办事项、制定项目计划等。 版本控制：通过 Magit 插件，可以获得顶级的 Git 操作体验。 浏览网页、听音乐、聊天，甚至玩游戏。 Emacs 可以在几乎所有的操作系统上运行，包括 Linux、macOS 和 Windows。\nEmacs 不仅仅是一个让你写代码或文章的工具，它更像一个为你量身定做的工作环境。你可以根据自己的需求，把它打造成一个极简的写作工具，或者一个无所不能的“瑞士军刀”。它的学习曲线比较陡峭，但一旦掌握，它将为你提供无与伦-比的自由度和工作效率。\nEmacs 安装教程 以 Ubuntu/Debian 为例，按下快捷键 CTRL + ALT + T 打开终端(控制台)，输入如下命令:\nsudo apt-get update\t# 更新本地软件列表 sudo apt-get install emacs # 安装 Emacs 上方截图主要意思是你是否需要配置邮件功能\nNo configuration 不配置 Internet site 互联网站点(将本机变成邮件服务器[需要公网IP]) Internet with smarthost 将邮件中转发送到网络邮件服务器 Satellite system 卫星系统(将邮件转发到中央邮件服务器) 根据自己喜好或需求选择然后按下Enter继续安装。\n","date":"2025-08-22T15:15:00+08:00","permalink":"http://localhost:1313/post/developmenttools/emacs/","title":"Emacs"},{"content":"什么是ADFGVX密码？ ADFGVX密码是一种在第一次世界大战期间由德国陆军使用的分段密码（Fractionating Cipher），它结合了**替换（Substitution）和换位（Transposition）**两种加密方式。这种密码由德国军官弗里茨·内贝尔（Fritz Nebel）于1918年发明，最初的版本是ADFGX密码，后来为了增加数字的加密能力，加入了字母V，演变为ADFGVX密码。\nADFGVX密码的名称来源于其密文使用的六个字母：A、D、F、G、V、X。选择这些字母是为了避免在摩尔斯电码传输时出现混淆，因为它们的摩尔斯电码差异较大。\n这种密码的复杂性远超之前的凯撒密码、维吉尼亚密码等，因为它引入了多阶段加密，使得频率分析等传统破解方法变得更加困难。它在战争中被用于传输重要的军事信息，直到法国密码分析师乔治·潘文（Georges Painvin）成功将其破解。\nADFGVX密码的工作原理主要分为两个阶段：\n替换阶段（Substitution）： 使用一个5x5（对于ADFGX）或6x6（对于ADFGVX）的波利比奥斯方阵（Polybius Square）将明文中的每个字符替换为一对ADFGVX字母。这个方阵是根据一个密钥单词随机填充的。 换位阶段（Transposition）： 将替换后的密文（现在是一串ADFGVX字母）写入一个矩阵中，然后根据另一个密钥单词的字母顺序对列进行重新排列，从而实现换位加密。 这两个阶段的结合使得ADFGVX密码在当时具有相当高的安全性。\nADFGVX密码的工作原理 ADFGVX密码的加密过程分为两个主要步骤：分段替换和列换位。\n1. 分段替换（Substitution） 这一阶段使用一个6x6的方阵，其中包含26个英文字母和10个数字（0-9）。这个方阵的填充顺序是根据一个密钥单词（例如 PHRASE）来确定的，首先填入密钥单词中不重复的字母，然后按字母表顺序填入剩余的字母和数字。方阵的行和列都用ADFGVX这六个字母标记。\n示例方阵 (密钥 PHRASE):\nA D F G V X A P H R A S E D B C D F G I F J K L M N O G Q T U V W X V Y Z 0 1 2 3 X 4 5 6 7 8 9 替换步骤：\n明文标准化： 将明文中的所有字母转换为大写，并移除所有非字母数字字符。\n查找替换： 将明文中的每个字符替换为其在方阵中的坐标。坐标由行标签和列标签组成。例如，如果明文是 ATTACK：\nA 在方阵中位于 AG。 T 在方阵中位于 GD。 T 在方阵中位于 GD。 A 在方阵中位于 AG。 C 在方阵中位于 DC。 K 在方阵中位于 DI。 替换后的结果是：AGGDGDAGDCDI。\n2. 列换位（Transposition） 这一阶段使用另一个密钥单词（例如 GERMAN）进行列换位。替换阶段生成的密文（一串ADFGVX字母）被写入一个矩阵中，矩阵的列数等于换位密钥的长度。然后，根据换位密钥字母的字母顺序对矩阵的列进行重新排列。\n换位步骤：\n构建矩阵： 将替换阶段生成的密文逐行填入一个矩阵中，矩阵的列数等于换位密钥的长度。 例如，替换后的密文 AGGDGDAGDCDI，换位密钥 GERMAN (长度为6)。\nG E R M A N A G G D G D A G D C D I 列排序： 根据换位密钥字母的字母顺序对列进行排序。GERMAN 排序后是 AEGMNR。\n原始列顺序： G (AG) E (GD) R (GD) M (AG) A (DC) N (DI)\n排序后的列顺序： A (DC) E (GD) G (AG) M (AG) N (DI) R (GD)\n读取密文： 按照排序后的列顺序，从上到下逐列读取矩阵中的字母，形成最终的密文。\n最终密文：DCA GGD AG AGD IDG (通常会去除空格)\n综合加密示例:\n明文 (Plaintext): ATTACK 替换方阵密钥 (Substitution Key): PHRASE 换位密钥 (Transposition Key): GERMAN 替换阶段： ATTACK -\u0026gt; AGGDGDAGDCDI\n换位阶段： 将 AGGDGDAGDCDI 填入以 GERMAN 为列头的矩阵：\nG E R M A N A G G D G D A G D C D I 按字母顺序排序 GERMAN -\u0026gt; AEGMNR，并重新排列列：\nA E G M N R G G A D D G D G A C I D 从上到下逐列读取：GD GG AA DC DI GD\n最终密文 (Ciphertext): GDGG AADC DIDG (通常为了传输方便，会分成5个一组) 解密过程则是加密的逆过程，首先进行列逆换位，然后进行分段逆替换。\n如何破解ADFGVX密码？ ADFGVX密码在第一次世界大战期间被认为是相当安全的，因为它结合了替换和换位两种复杂的加密机制，使得传统的频率分析方法难以直接应用。然而，法国密码分析师乔治·潘文（Georges Painvin）在1918年成功破解了这种密码，这被认为是密码学史上的一个重大突破。\n破解ADFGVX密码的关键在于其两阶段的加密过程，需要分别攻击替换和换位。\n1. 攻击换位阶段：确定换位密钥长度 破解的第一步是确定换位密钥的长度。潘文的方法主要依赖于频率分析和重合指数法，但需要更复杂的应用。\n重合指数法（Index of Coincidence, IC）： 尽管ADFGVX密码经过替换和换位，但如果能正确地猜测换位密钥的长度，将密文重新排列成原始的列，那么每一列的字母仍然是经过波利比奥斯方阵替换后的结果。通过计算不同假设密钥长度下，重新排列后的列的重合指数，可以寻找接近随机文本重合指数（对于ADFGVX字母表，其重合指数会与26个字母的有所不同，但仍然可以作为判断依据）的模式。当重合指数出现显著变化时，可能就找到了正确的密钥长度。\n统计分析： 潘文利用了德语中字母频率的统计特性。虽然ADFGVX密文看起来是随机的，但如果能正确地将密文分解成原始的列，那么这些列的统计特性会反映出德语的某些特征。通过分析密文中重复出现的模式和它们的间距，可以推测换位密钥的长度。\n2. 攻击替换阶段：确定波利比奥斯方阵和替换密钥 一旦换位密钥的长度被确定，密文就可以被重新排列成原始的列。此时，每一列的字母实际上是经过波利比奥斯方阵替换后的结果。由于波利比奥斯方阵是固定的，因此可以对这些列进行频率分析来推断出原始的波利比奥斯方阵和替换密钥。\n频率分析： 尽管波利比奥斯方阵将一个字母替换为两个ADFGVX字母，但每个明文字母的出现频率仍然会影响到其对应的ADFGVX对的频率。通过分析这些ADFGVX对的频率，并与德语中字母和数字的频率进行比较，可以逐步推断出方阵中每个位置对应的字符。\n已知明文攻击： 如果攻击者能够获得一些明文和对应的密文对，那么破解难度将大大降低。通过比较明文和密文，可以直接推导出波利比奥斯方阵的映射关系和换位密钥。\n3. 组合密钥并解密 当替换密钥（波利比奥斯方阵的布局）和换位密钥都被确定后，就可以对密文进行逆向操作，首先进行逆换位，然后进行逆替换，从而恢复明文。\nADFGVX密码的破解是密码学发展史上的一个里程碑，它展示了即使是复杂的组合密码，在足够的数据和巧妙的分析方法面前，也并非不可攻破。潘文的成功不仅对第一次世界大战的进程产生了影响，也为后来的密码分析技术奠定了基础。\nC++ 代码实现 ADFGVX密码的C++实现相对复杂，因为它涉及两个阶段：替换和换位。下面是一个简化的C++程序，演示了ADFGVX密码的加密和解密过程。为了简化，这里将使用一个固定的波利比奥斯方阵，并假设明文只包含大写字母和数字。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cctype\u0026gt; // ADFGVX字母表 const std::string ADFGVX_CHARS = \u0026#34;ADFGVX\u0026#34;; // 固定的波利比奥斯方阵 (6x6) // 包含26个字母和10个数字 const char POLYBIUS_SQUARE[6][6] = { {\u0026#39;P\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;E\u0026#39;}, {\u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;I\u0026#39;}, {\u0026#39;J\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;O\u0026#39;}, {\u0026#39;Q\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;U\u0026#39;, \u0026#39;V\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;X\u0026#39;}, {\u0026#39;Y\u0026#39;, \u0026#39;Z\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;}, {\u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;} }; // 用于快速查找字符坐标的映射 std::map\u0026lt;char, std::pair\u0026lt;int, int\u0026gt;\u0026gt; charToCoords; // 初始化字符到坐标的映射 void initializeCharToCoords() { for (int i = 0; i \u0026lt; 6; ++i) { for (int j = 0; j \u0026lt; 6; ++j) { charToCoords[POLYBIUS_SQUARE[i][j]] = {i, j}; } } } // 将明文替换为ADFGVX坐标对 std::string substitute(const std::string\u0026amp; plaintext) { std::string substitutedText = \u0026#34;\u0026#34;; for (char c : plaintext) { c = toupper(c); // 转换为大写 if (charToCoords.count(c)) { substitutedText += ADFGVX_CHARS[charToCoords[c].first]; substitutedText += ADFGVX_CHARS[charToCoords[c].second]; } else if (isdigit(c)) { // 处理数字 // 查找数字在方阵中的位置 bool found = false; for (int i = 0; i \u0026lt; 6; ++i) { for (int j = 0; j \u0026lt; 6; ++j) { if (POLYBIUS_SQUARE[i][j] == c) { substitutedText += ADFGVX_CHARS[i]; substitutedText += ADFGVX_CHARS[j]; found = true; break; } } if (found) break; } } else { // 忽略非字母数字字符 } } return substitutedText; } // 根据换位密钥进行列换位加密 std::string transposeEncrypt(const std::string\u0026amp; substitutedText, const std::string\u0026amp; key) { std::string cleanKey = \u0026#34;\u0026#34;; for (char c : key) { if (isalpha(c)) { cleanKey += toupper(c); } } int keyLength = cleanKey.length(); if (keyLength == 0) return substitutedText; // No transposition if key is empty int numRows = (substitutedText.length() + keyLength - 1) / keyLength; std::vector\u0026lt;std::vector\u0026lt;char\u0026gt;\u0026gt; grid(numRows, std::vector\u0026lt;char\u0026gt;(keyLength, \u0026#39; \u0026#39;)); int textIndex = 0; for (int r = 0; r \u0026lt; numRows; ++r) { for (int c = 0; c \u0026lt; keyLength; ++c) { if (textIndex \u0026lt; substitutedText.length()) { grid[r][c] = substitutedText[textIndex++]; } } } // 创建密钥索引对，用于排序 std::vector\u0026lt;std::pair\u0026lt;char, int\u0026gt;\u0026gt; keyOrder(keyLength); for (int i = 0; i \u0026lt; keyLength; ++i) { keyOrder[i] = {cleanKey[i], i}; } std::sort(keyOrder.begin(), keyOrder.end()); std::string ciphertext = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; keyLength; ++i) { int originalCol = keyOrder[i].second; for (int r = 0; r \u0026lt; numRows; ++r) { if (grid[r][originalCol] != \u0026#39; \u0026#39;) { ciphertext += grid[r][originalCol]; } } } return ciphertext; } // 根据换位密钥进行列逆换位解密 std::string transposeDecrypt(const std::string\u0026amp; ciphertext, const std::string\u0026amp; key) { std::string cleanKey = \u0026#34;\u0026#34;; for (char c : key) { if (isalpha(c)) { cleanKey += toupper(c); } } int keyLength = cleanKey.length(); if (keyLength == 0) return ciphertext; // No transposition if key is empty int numRows = (ciphertext.length() + keyLength - 1) / keyLength; std::vector\u0026lt;std::vector\u0026lt;char\u0026gt;\u0026gt; grid(numRows, std::vector\u0026lt;char\u0026gt;(keyLength, \u0026#39; \u0026#39;)); // 计算每列的长度 std::vector\u0026lt;int\u0026gt; colLengths(keyLength); int remaining = ciphertext.length(); for (int i = 0; i \u0026lt; keyLength; ++i) { colLengths[i] = numRows; if (remaining % keyLength != 0 \u0026amp;\u0026amp; i \u0026gt;= (keyLength - (numRows * keyLength - ciphertext.length()))) { colLengths[i]--; // 最后一行的空位 } remaining -= colLengths[i]; } // 重新构建密钥索引对，用于排序 std::vector\u0026lt;std::pair\u0026lt;char, int\u0026gt;\u0026gt; keyOrder(keyLength); for (int i = 0; i \u0026lt; keyLength; ++i) { keyOrder[i] = {cleanKey[i], i}; } std::sort(keyOrder.begin(), keyOrder.end()); // 填充网格 int currentCipherIndex = 0; for (int i = 0; i \u0026lt; keyLength; ++i) { int originalCol = keyOrder[i].second; for (int r = 0; r \u0026lt; colLengths[originalCol]; ++r) { grid[r][originalCol] = ciphertext[currentCipherIndex++]; } } std::string substitutedText = \u0026#34;\u0026#34;; for (int r = 0; r \u0026lt; numRows; ++r) { for (int c = 0; c \u0026lt; keyLength; ++c) { if (grid[r][c] != \u0026#39; \u0026#39;) { substitutedText += grid[r][c]; } } } return substitutedText; } // 将ADFGVX坐标对逆替换回明文 std::string substituteDecrypt(const std::string\u0026amp; substitutedText) { std::string plaintext = \u0026#34;\u0026#34;; for (size_t i = 0; i \u0026lt; substitutedText.length(); i += 2) { char rowChar = substitutedText[i]; char colChar = substitutedText[i+1]; int row = ADFGVX_CHARS.find(rowChar); int col = ADFGVX_CHARS.find(colChar); if (row != std::string::npos \u0026amp;\u0026amp; col != std::string::npos) { plaintext += POLYBIUS_SQUARE[row][col]; } } return plaintext; } int main() { initializeCharToCoords(); // 初始化映射 std::string plaintext; std::string transpositionKey; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; ADFGVX密码加密/解密程序\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;\\n请输入要加密的消息 (只包含字母和数字): \u0026#34;; std::getline(std::cin, plaintext); std::cout \u0026lt;\u0026lt; \u0026#34;请输入换位密钥 (只包含字母): \u0026#34;; std::getline(std::cin, transpositionKey); // 加密过程 std::string substituted = substitute(plaintext); std::string encrypted = transposeEncrypt(substituted, transpositionKey); std::cout \u0026lt;\u0026lt; \u0026#34;\\n加密后的密文是: \u0026#34; \u0026lt;\u0026lt; encrypted \u0026lt;\u0026lt; std::endl; // 解密过程 std::string decryptedSubstituted = transposeDecrypt(encrypted, transpositionKey); std::string decryptedPlaintext = substituteDecrypt(decryptedSubstituted); std::cout \u0026lt;\u0026lt; \u0026#34;解密后的明文是: \u0026#34; \u0026lt;\u0026lt; decryptedPlaintext \u0026lt;\u0026lt; std::endl; return 0; } ","date":"2025-08-21T17:37:00+08:00","permalink":"http://localhost:1313/post/programmingtechnology/classicalcryptography/adfgvx/","title":"ADFGVX密码"},{"content":"创建 Telegram Bot 在 Telegram 中搜索 @BotFather 在对话框中发送 /newbot 输入机器人名称 (用作称呼) 输入机器人用户名以 (bot/Bot) 结尾 (用作机器人账号) 接下来你就会获得一串 Token (请勿泄漏 拥有 Token 就代表掌握了 Bot 的绝对权限) 测试 Telegram Bot https://api.telegram.org/bot\u0026lt;YourToken\u0026gt;/getMe 将 \u0026lt;YourToken\u0026gt; 替换为你 Bot 的完整 Token，复制到浏览器即可查看到 Bot 的相关信息。\n对于 Telegram Bot API 的所有操作都必须通过 HTTPS 进行通信，并且需要使用以下形式呈现:\nhttps://api.telegram.org/bot\u0026lt;YourToken\u0026gt;/方法名称 使用本地 Bot API Server Bot API 服务器源代码可在 Telegram-Bot-API 处获得。您可以在本地运行它,并将请求发送到您自己的服务器,而不是 https://api.telegram.org 如果切换到本地 Bot API 服务器,您的机器人将能够:\n下载没有大小限制的文件。 上传文件高达2000 MB。 使用其本地路径和文件 URI 方案上传文件。 使用 HTTP URL 进行 webhook。 使用任何本地 IP 地址的 webhook。 使用任何端口的webhook。 设置 max_webhook_connections 高达 100000。 接收绝对本地路径作为 file_path 字段的值,无需在 getFile 请求后下载文件。 获取更新 有两种互斥的方式可以接收机器人的更新 —— 一种是getUpdates方法，另一种是网络钩子（webhooks）。传入的更新会存储在服务器上，直到机器人通过这两种方式中的任意一种接收它们，但这些更新的保存时间不会超过 24 小时。\n无论你选择哪种方式，最终都会收到 JSON 序列化的 Update 对象。\nUpdate - 更新 该对象表示一个传入的更新。在任何给定的更新中，最多只能有一个可选参数存在。\n字段 类型 描述 update_id 整数 更新的唯一标识符 从特定正数开始依次递增 使用网络钩子时可忽略重复更新或恢复顺序 若一周无更新则下个ID随机生成 message 消息 可选 新收到的文本、照片、贴纸等消息 edited_message 消息 可选 已知消息被编辑后的新版本 channel_post 消息 可选 新收到的频道帖子 edited_channel_post 消息 可选 已知频道帖子被编辑后的新版本 business_connection 业务连接 可选 机器人连接/断开业务账户或用户编辑连接时触发 business_message 消息 可选 来自业务账户的新消息 edited_business_message 消息 可选 业务账户消息被编辑后的版本 deleted_business_messages 业务消息已删除 可选 业务账户消息被删除时触发 message_reaction 消息反应已更新 可选 用户更改消息反应（需管理员权限并在allowed_updates指定） message_reaction_count 消息反应计数已更新 可选 匿名消息反应数变更（需管理员权限并在allowed_updates指定 可能延迟） inline_query 内联查询 可选 新收到的内联查询 chosen_inline_result 选择的内联结果 可选 用户选择内联结果并发送 callback_query 回调查询 可选 新收到的回调查询 shipping_query 物流查询 可选 新物流查询（仅灵活价格发票） pre_checkout_query 预结账查询 可选 新预结账查询（含完整信息） purchased_paid_media 付费媒体已购买 可选 用户在非频道聊天购买机器人发送的付费媒体 poll 投票 可选 投票状态更新（仅手动停止或机器人发送的投票） poll_answer 投票答案 可选 用户更改非匿名投票答案（仅机器人发送的投票） my_chat_member 聊天成员已更新 可选 机器人成员状态更新（私聊中仅触发于屏蔽/解封） chat_member 聊天成员已更新 可选 成员状态更新（需管理员权限并在allowed_updates指定） chat_join_request 加群请求 可选 加群请求（需can_invite_users权限） chat_boost 聊天加速已更新 可选 聊天加速状态新增/变更（需管理员权限） removed_chat_boost 聊天加速已移除 可选 聊天加速状态移除（需管理员权限） getUpdates - 获取更新 使用此方法通过长轮询接收传入的更新。返回一个由 Update 对象组成的数组。\n参数 类型 必填 描述 offset 整数 可选 要返回的第一个更新标识符\n• 必须比已接收的最高ID大1\n• 默认返回最早未确认更新\n• 负值获取队列末尾更新（如-5获取最后5条） limit 整数 可选 获取更新数量限制\n• 范围：1-100\n• 默认值：100 timeout 整数 可选 长轮询超时时间（秒）\n• 0=短轮询（默认）\n• 正值=长轮询等待时间\n• 短轮询仅建议测试使用 allowed_updates 字符串数组 可选 允许接收的更新类型（JSON格式）\n• 示例：[\u0026quot;message\u0026quot;,\u0026quot;callback_query\u0026quot;]\n• 空数组=接收除三类敏感更新外的所有类型\n• 不设置=沿用上次配置\n• 注意：不影响调用前已生成的更新 ","date":"2025-08-18T18:26:08+08:00","permalink":"http://localhost:1313/post/programmingtechnology/developmentdocumentation/telegrambotapi/","title":"Telegram Bot API"},{"content":"递归（recursion）在 C++ 中本质上是函数调用自身，因此性能瓶颈主要来自以下几点：\n函数调用栈的开销（保存返回地址、参数、局部变量等） 每次调用的指令跳转 编译器优化（例如尾递归优化） 一、递归性能低的根源 假设你有一个简单的递归函数：\nint factorial(int n) { if (n \u0026lt;= 1) return 1; return n * factorial(n - 1); } 这里的每次调用都要：\n压栈 n 的值； 压栈返回地址； 创建新的栈帧； 执行函数跳转； 因此，递归调用多层后性能下降明显，甚至会触发栈溢出。\n二、高性能递归的关键优化策略 ✅ 1. 尾递归优化（Tail Recursion Optimization） 尾递归是最常见的“高性能递归”技巧。 当一个函数的最后一步操作是调用自身，编译器可以将递归转换为循环，避免栈增长。\n例：\nint factorial_tail(int n, int acc = 1) { if (n \u0026lt;= 1) return acc; return factorial_tail(n - 1, acc * n); } 如果编译器支持 尾调用优化 (TCO)，这段代码性能几乎等同于循环。 不过：\nMSVC 不会优化尾递归； Clang / GCC 在 -O2 或更高优化等级时会自动优化； 🔹 强制优化方式：\ng++ -O3 -foptimize-sibling-calls main.cpp -o main ✅ 2. 将递归改写为迭代（显式栈模拟） 当尾递归优化不可用时，可以手动用栈代替系统调用栈。\n例：DFS 遍历递归改为迭代\nvoid dfs_iterative(Node* root) { std::stack\u0026lt;Node*\u0026gt; stack; stack.push(root); while (!stack.empty()) { Node* node = stack.top(); stack.pop(); // 访问节点 for (auto\u0026amp; child : node-\u0026gt;children) stack.push(child); } } 这样就可以完全避免递归调用的栈开销。\n✅ 3. 使用模板元编程（编译期递归） 对于能在编译期计算的递归（例如斐波那契常数、阶乘），可以使用 constexpr 或模板元编程。\nconstexpr int factorial_constexpr(int n) { return n \u0026lt;= 1 ? 1 : n * factorial_constexpr(n - 1); } 这种递归在编译期完成计算，运行时几乎零开销。\n✅ 4. 内联递归（inline） 在少量递归层次时，可尝试 inline 提示编译器展开（不过递归一般不会被完全展开）。\ninline int sum(int n) { return n == 0 ? 0 : n + sum(n - 1); } 但多数情况下编译器不会展开真正递归函数，只在递归深度较浅的地方展开。\n✅ 5. 记忆化（Memoization） 对重复子问题的递归（如斐波那契数列）使用缓存表避免重复计算：\nint fib_memo(int n, std::vector\u0026lt;int\u0026gt;\u0026amp; cache) { if (n \u0026lt;= 1) return n; if (cache[n] != -1) return cache[n]; return cache[n] = fib_memo(n-1, cache) + fib_memo(n-2, cache); } 缓存结果可以让复杂度从 O(2ⁿ) 降为 O(n)。\n✅ 6. 手动展开少量递归层级 有时可以手动展开前几层调用，减少函数跳转次数：\nint sum(int n) { if (n \u0026lt;= 4) return (n * (n + 1)) / 2; return n + (n-1) + (n-2) + (n-3) + sum(n - 4); } 这在数学递归（例如分治算法）中有效。\n✅ 7. 使用尾调用风格的 Lambda C++17 起支持“内联递归 lambda”：\nauto factorial = [](auto self, int n, int acc = 1) -\u0026gt; int { if (n \u0026lt;= 1) return acc; return self(self, n - 1, acc * n); }; int result = factorial(factorial, 10); 配合 -O3 编译，性能与普通尾递归一致。\n三、性能对比（以 GCC 13 / -O3 测试） 实现方式 平均耗时（n=10^6） 栈消耗 可优化性 普通递归 ❌ 极慢 (爆栈风险) 高 差 尾递归（优化） ✅ 接近循环 低 好 显式栈迭代 ✅ 稍快 可控 高 constexpr / 模板 ⚡ 编译期完成 0 极高 Memoization ✅ 极快（适合重复子问题） 中 高 ✅ 结论总结 场景 推荐方式 数学递归（阶乘、斐波那契） constexpr 或 尾递归优化 树/图遍历 手动栈 + 迭代实现 深度不大、结构清晰 普通递归即可 重复子问题 记忆化递归 编译器不支持尾调用 显式循环重写 ","date":"2025-08-17T16:30:00+08:00","permalink":"http://localhost:1313/post/programmingtechnology/c++-performance-optimization/development-environment/","title":"C++ 性能优化之递归"},{"content":"什么是开发环境？ 在计算机编程领域，开发环境（Development Environment）是指一套允许程序员编写、编译、调试和运行代码的工具和设置的集合。它不仅仅是您编写代码的文本编辑器，更是一个集成了编译器、调试器、构建系统、版本控制工具等多种组件的综合性平台。没有一个完整的开发环境，您所编写的代码将仅仅是普通的文本文件，无法被计算机理解和执行。\n一个典型的 C++ 开发环境通常包括以下核心组件：\n编译器（Compiler）：将您用C++编写的源代码转换成机器可执行的二进制代码。对于C++而言，GCC（GNU Compiler Collection）和Clang是最常用且功能强大的编译器。 调试器（Debugger）：用于帮助程序员查找和修复代码中的错误（Bug）。它允许您逐行执行代码、检查变量的值、设置断点等，从而深入理解程序的运行状态。GDB（GNU Debugger）是Linux环境下常用的C++调试器。 构建系统（Build System）：自动化编译和链接过程的工具。当项目包含多个源文件和库时，手动编译会变得非常繁琐。Make和CMake是两种常见的构建系统，它们能够根据项目配置自动管理编译流程。 代码编辑器/集成开发环境（IDE）：提供编写代码的界面，并通常集成了编译器、调试器、构建系统等功能，提供代码高亮、自动补全、错误检查等高级特性，极大地提升开发效率。例如，CLion、Visual Studio Code、Visual Studio等。 选择和配置合适的开发环境，将直接影响您的开发体验和效率。\n操作系统推荐 尽管任何操作系统理论上都可以进行编程，但为了追求更高的开发效率、程序运行的稳定性以及第三方库安装的便捷性，强烈推荐使用基于 Linux 内核的操作系统进行 C++ 开发。在众多 Linux 发行版中，Ubuntu 因其庞大的用户社区、丰富的软件仓库和对新手友好的特性，成为初学者的理想选择。\nLinux的优势 开源特性：Linux是开源的，这意味着您可以访问其源代码，这对于理解系统底层运作机制、进行深度定制以及解决开发中遇到的问题非常有帮助。 系统稳定性：Linux以其卓越的稳定性而闻名，这对于长时间运行的开发任务和服务器应用至关重要。 丰富的开发资源与生态：Linux拥有一个活跃且庞大的开发者社区，您可以轻而易举地找到各种开发资料、教程、开源项目和解决方案。几乎所有的主流开发工具和库都原生支持Linux。 高效的命令行工具：Linux的命令行界面（CLI）提供了强大的工具集，可以高效地管理文件、执行脚本、编译代码和部署应用，这对于C++开发尤其重要。 容器化技术友好：Docker、Kubernetes等容器化技术在Linux环境下运行最为高效和稳定，这对于现代软件开发和部署是不可或缺的。 Ubuntu下载与安装 对于初次接触Linux的用户，Ubuntu提供了直观的桌面环境和简化的安装流程。您可以从官方渠道获取最新版本的Ubuntu：\nUbuntu官方下载地址：https://www.ubuntu.com/download/desktop Ubuntu官方安装教程：https://www.ubuntu.com/tutorials/install-ubuntu-desktop 其他操作系统考量 Windows：对于Windows用户，推荐使用适用于Linux的Windows子系统（WSL）。WSL允许您在Windows上运行一个完整的Linux环境，同时保留Windows的桌面体验。这是一种兼顾两者优势的流行选择。 macOS：macOS基于Unix，与Linux有许多相似之处，因此也是一个优秀的C++开发平台。Xcode Command Line Tools提供了必要的编译器和工具链。 无论您选择哪种操作系统，理解其核心概念并配置好开发环境是成功的关键。接下来，我们将详细介绍如何在Linux（以Ubuntu为例）上配置C++开发工具链。\nC++开发环境配置：核心工具链 在任何操作系统中，要进行编程，首先需要配置一套完整的开发环境。对于C++而言，这意味着安装一系列必要的工具，它们将您的源代码转化为可执行程序。以下将以Ubuntu系统为例，详细介绍如何配置C++开发环境所需的核心组件。\n打开终端 在Ubuntu系统中，终端（Terminal）是执行命令行操作的入口。您可以通过以下方式打开终端：\n快捷键：按下 Ctrl + Alt + T。 应用程序菜单：点击左侧或底部的应用程序图标，搜索“终端”并启动。 安装核心组件 打开终端后，您可以输入以下命令来安装C++开发环境所需的关键组件。这些命令通常需要管理员权限，因此会用到sudo（superuser do）命令。\n更新本地软件包列表： 在安装任何新软件之前，建议先更新您的软件包列表，以确保您安装的是最新版本的软件。\nsudo apt-get update 安装GCC编译器： GCC（GNU Compiler Collection）是GNU项目开发的编译器套件，支持C、C++、Objective-C等多种语言。它是C++开发的基础。\nsudo apt-get install gcc 安装G++编译器： G++是GCC套件中专门用于编译C++程序的编译器。它是C++开发不可或缺的工具。\nsudo apt-get install g++ 安装GDB调试器： GDB（GNU Debugger）是一个强大的命令行调试器，用于帮助您查找和修复C++程序中的错误。它允许您在程序运行时检查变量、设置断点、单步执行等。\nsudo apt-get install gdb 安装Make构建器： Make是一个自动化构建工具，它根据Makefile文件中的规则来编译和链接程序。对于中小型项目，Make非常实用。\nsudo apt-get install make 安装CMake构建生成器： CMake是一个跨平台的构建系统生成器。它不直接构建项目，而是生成特定于平台的构建文件（如Makefile或Visual Studio项目文件），然后由这些文件来实际构建项目。对于大型和跨平台项目，CMake是首选。\nsudo apt-get install cmake 自动化安装（不推荐） 如果您希望一次性安装所有常用的C/C++开发工具，可以使用build-essential软件包。它是一个元软件包，包含了GCC、G++、Make以及其他一些常用的开发库和工具。这是一种更便捷的安装方式，但不适合初学者，因为如果想要学习配置开发环境并且让自己有一个深刻的印象的话这个方式显然不行，他无法让你深刻的记住每个必备的组件都是什么。\nsudo apt-get install build-essential 安装完成后，您可以通过在终端输入相应命令（如g++ --version、gdb --version、make --version、cmake --version）来验证这些工具是否成功安装并查看其版本信息。\n验证安装 安装完成后，您可以通过在终端输入以下命令来验证这些工具是否成功安装并查看其版本信息：\n验证GCC版本：\ngcc --version 验证G++版本：\ng++ --version 验证GDB版本：\ngdb --version 验证Make版本：\nmake --version 验证CMake版本：\ncmake --version 如果命令成功执行并显示版本信息，则表明相应的工具已正确安装。如果遇到“command not found”或其他错误，请检查您的拼写，并确保在安装过程中没有出现错误。\n高效的开发工具：工欲善其事，必先利其器 编写代码离不开一个好用的开发工具。一个适合自己的代码编辑器或集成开发环境（IDE）能够极大地提升您的编程体验和效率。正所谓“工欲善其事，必先利其器”，选择一个趁手的工具对于C++的学习和开发至关重要。\n集成开发环境（IDE） 集成开发环境（IDE）通常集成了代码编辑器、编译器、调试器和构建工具等多种功能，提供一站式的开发体验。它们通常拥有强大的代码分析、自动补全、重构和项目管理能力。\nCLion CLion是JetBrains公司开发的一款专为C及C++设计的跨平台IDE。它以其智能的代码辅助、强大的代码分析、集成的调试器和对CMake的良好支持而闻名。CLion拥有庞大的插件市场，可以根据您的需求进行扩展。对于学生和开源贡献者，JetBrains通常提供免费的个人许可证。\nCLion官方下载地址：https://www.jetbrains.com/clion/ CLion官方安装教程：https://www.jetbrains.com/help/clion/installation-guide.html Visual Studio (Windows) Visual Studio是微软为Windows平台开发的功能强大的IDE，支持C++、C#、.NET等多种语言。它提供了丰富的开发工具、调试功能和项目模板，是Windows环境下C++开发的标准选择。Visual Studio Community版本对个人开发者和开源项目免费。\nXcode (macOS) Xcode是苹果公司为macOS平台开发的IDE，主要用于开发macOS、iOS、watchOS和tvOS应用程序。它内置了Clang编译器和LLDB调试器，是macOS环境下C++开发的官方工具。\n轻量级代码编辑器 对于更喜欢轻量级、高度可定制的开发环境的开发者，代码编辑器是更好的选择。它们通常通过安装插件来扩展功能，以满足C++开发的需求。\nVisual Studio Code (VS Code) Visual Studio Code是一款由微软开发的免费、开源的跨平台代码编辑器。它以其轻量级、高性能、丰富的扩展生态系统和对多种编程语言的良好支持而迅速普及。通过安装C/C++扩展包，VS Code可以提供智能感知、调试、代码格式化等功能，使其成为C++开发的优秀选择。\nVS Code官方下载地址：https://code.visualstudio.com/ 推荐C/C++扩展：Microsoft C/C++ Extension Pack Vim / Emacs Vim和Emacs是两款历史悠久、功能强大的文本编辑器，主要面向资深开发者和系统管理员。它们拥有极高的可定制性，可以通过配置和插件实现IDE级别的功能。虽然学习曲线陡峭，但一旦掌握，可以极大地提高编码效率。\n如何选择？ 初学者：推荐从CLion或Visual Studio Code开始。CLion提供了一站式的便利，而VS Code则提供了轻量级和高度可定制的平衡。 Windows用户：可以考虑Visual Studio或结合WSL使用VS Code。 macOS用户：Xcode是官方选择，CLion和VS Code也是不错的跨平台替代品。 Linux用户：CLion和VS Code都是极佳的选择，也可以直接使用命令行工具和文本编辑器（如Vim/Emacs）。 最重要的是选择一个您用起来舒适、能够提高效率的工具。建议您可以尝试几种不同的工具，找到最适合自己的那一款。\n编写并编译您的第一个C++程序 配置好开发环境后，让我们来编写并编译您的第一个C++程序，以验证所有工具是否协同工作。\n编写源代码 首先，创建一个名为 hello_world.cpp 的文件，并写入以下代码：\n#include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello, World!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } #include \u0026lt;iostream\u0026gt;：这是一个预处理指令，告诉编译器包含 iostream 库，它提供了输入/输出流功能，例如 std::cout 用于向控制台输出文本。 int main() { ... }：这是C++程序的入口点。所有C++程序都从 main 函数开始执行。 std::cout \u0026lt;\u0026lt; \u0026quot;Hello, World!\u0026quot; \u0026lt;\u0026lt; std::endl;：这行代码使用 std::cout 对象将字符串 \u0026ldquo;Hello, World!\u0026rdquo; 输出到标准输出（通常是终端），std::endl 用于插入一个换行符并刷新输出缓冲区。 return 0;：表示程序成功执行并退出。 编译程序 保存文件后，打开终端，导航到您保存 hello_world.cpp 文件的目录。然后使用G++编译器编译您的程序：\ng++ hello_world.cpp -o hello_world g++：调用C++编译器。 hello_world.cpp：指定要编译的源文件。 -o hello_world：指定输出可执行文件的名称为 hello_world。如果您省略此选项，可执行文件将默认为 a.out。 如果编译成功，您将不会看到任何输出。如果出现错误，编译器会显示相应的错误信息，您需要根据提示修改代码。\n运行程序 编译成功后，您可以通过以下命令运行生成的可执行文件：\n./hello_world 您应该会在终端看到输出：\nHello, World! 恭喜您！您已经成功配置了C++开发环境，并编写、编译、运行了您的第一个C++程序。这标志着您C++学习之旅的正式开始。\n参考资料 Ubuntu官方下载地址 Ubuntu官方安装教程 JetBrains CLion官方网站 JetBrains CLion安装教程 Visual Studio Code官方网站 ","date":"2025-08-17T16:30:00+08:00","permalink":"http://localhost:1313/post/programmingtechnology/c++-self-study-guide/development-environment/","title":"开发环境搭建"},{"content":"什么是波利比奥斯方阵密码？ 波利比奥斯方阵密码（Polybius Square Cipher），又称棋盘密码，是一种替换密码（Substitution Cipher），由古希腊历史学家波利比奥斯（Polybius）在公元前2世纪发明。它将字母映射到数字对，从而实现加密。这种密码最初是为了通过火炬信号进行远距离通信而设计的，每个字母通过其在方阵中的坐标来表示。\n波利比奥斯方阵通常是一个5x5的网格，包含了25个英文字母。由于英文字母有26个，通常会将字母 I 和 J 合并处理，或者将 K 替换为 C 等，以适应25个格子的限制。每个字母由其所在的行号和列号组成的数字对来表示。\n波利比奥斯方阵示例 (5x5):\n1 2 3 4 5 1 A B C D E 2 F G H I/J K 3 L M N O P 4 Q R S T U 5 V W X Y Z 加密过程：\n构建方阵： 确定一个5x5的方阵，将字母填入其中。通常 I 和 J 共用一个格子。 明文转换： 将明文中的每个字母替换为其在方阵中的坐标对。坐标通常是先行后列。 例如，如果明文是 HELLO：\nH 在第2行第3列，表示为 23。 E 在第1行第5列，表示为 15。 L 在第3行第1列，表示为 31。 L 在第3行第1列，表示为 31。 O 在第3行第4列，表示为 34。 加密示例:\n明文 (Plaintext): HELLO 密文 (Ciphertext): 2315313134 波利比奥斯方阵密码的数学表示 波利比奥斯方阵密码的数学表示相对简单，它主要涉及将字母映射到二维坐标，然后将这些坐标串联起来。虽然没有像凯撒密码或维吉尼亚密码那样直接的模运算公式，但其核心是基于查表和坐标转换。\n设：\n字母表 Σ = {A, B, ..., Z} 方阵 M 是一个 5x5 的矩阵，其中 M[row][col] 存储一个字母。 char_to_coords(c) 函数返回字母 c 在方阵 M 中的坐标 (row, col)。 coords_to_char(row, col) 函数返回坐标 (row, col) 在方阵 M 中对应的字母。 加密过程：\n对于明文中的每个字母 P_i：\n找到 P_i 在方阵 M 中的坐标 (row_i, col_i)。 将 row_i 和 col_i 转换为字符串形式，并连接起来形成密文的一部分。 解密过程：\n对于密文中的每对数字 (d1, d2)：\n将 d1 解释为行号 row，d2 解释为列号 col。 找到方阵 M 中 M[row][col] 对应的字母 P_i。 示例方阵 (5x5，I/J合并):\n1 2 3 4 5 1 A B C D E 2 F G H I/J K 3 L M N O P 4 Q R S T U 5 V W X Y Z 加密函数 (伪代码):\nfunction encrypt(plaintext): ciphertext = \u0026#34;\u0026#34; for each char P in plaintext: if P is an alphabet letter: if P == \u0026#39;J\u0026#39;: P = \u0026#39;I\u0026#39; // Handle I/J merge (row, col) = char_to_coords(P) ciphertext += to_string(row) + to_string(col) else: ciphertext += P // Non-alphabet characters remain unchanged return ciphertext 解密函数 (伪代码):\nfunction decrypt(ciphertext): plaintext = \u0026#34;\u0026#34; for i from 0 to length(ciphertext) - 1 step 2: d1 = to_int(ciphertext[i]) d2 = to_int(ciphertext[i+1]) P = coords_to_char(d1, d2) plaintext += P return plaintext 这种密码的数学表示更侧重于查找表和索引操作，而不是复杂的算术运算。\n如何破解波利比奥斯方阵密码？ 波利比奥斯方阵密码虽然将字母转换成了数字对，但它仍然是一种单表替换密码。这意味着每个明文字母总是被相同的数字对替换。因此，它和凯撒密码一样，容易受到频率分析的攻击。\n1. 频率分析 (Frequency Analysis) 这是破解波利比奥斯方阵密码最主要的方法。攻击者可以统计密文中每个数字对的出现频率，并将其与已知语言（例如英语）中字母的频率分布进行比较。例如，在英语中，字母 E 的出现频率最高，那么密文中出现频率最高的数字对很可能就代表 E。一旦确定了几个这样的对应关系，就可以逐步推断出整个方阵的映射关系，从而解密密文。\n破解步骤：\n统计密文频率： 将密文中的数字对（例如，23, 15 等）进行统计，找出出现频率最高的数字对。 匹配语言频率： 将这些高频数字对与目标语言（如英语）中高频字母（如 E, T, A, O, I, N 等）进行匹配。 重建方阵： 根据推断出的映射关系，逐步重建波利比奥斯方阵。 解密： 使用重建的方阵来解密整个密文。 2. 暴力破解 (Brute-force Attack) 虽然不如频率分析高效，但理论上也可以通过暴力破解来尝试所有可能的方阵排列。然而，由于方阵的排列组合数量巨大，这种方法在实践中是不可行的。\n3. 已知明文攻击 (Known-plaintext Attack) 如果攻击者拥有一些明文和对应的密文对，那么破解将变得非常容易。通过比较明文和密文，可以直接推导出方阵的映射关系。\n4. 字典攻击 (Dictionary Attack) 如果密文是短语或单词，攻击者可以尝试使用常见的单词或短语进行加密，然后与密文进行比较，以找到匹配项。\n总的来说，波利比奥斯方阵密码的安全性非常低，不适用于保护敏感信息。它主要作为密码学教学中的一个早期示例，展示了将字母转换为数字表示的初步尝试。\nC++ 代码实现 下面是一个简单的 C++ 程序，它实现了波利比奥斯方阵密码的加密和解密功能。代码结构清晰，并包含了详细的注释。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;map\u0026gt; // Define the Polybius Square (5x5, I/J combined) const char polybiusSquare[5][5] = { {\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;}, {\u0026#39;F\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;K\u0026#39;}, // I/J combined {\u0026#39;L\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;P\u0026#39;}, {\u0026#39;Q\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;U\u0026#39;}, {\u0026#39;V\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Z\u0026#39;} }; // Map to store character to coordinates for encryption std::map\u0026lt;char, std::pair\u0026lt;int, int\u0026gt;\u0026gt; charToCoords; // Function to initialize the charToCoords map void initializeMap() { for (int i = 0; i \u0026lt; 5; ++i) { for (int j = 0; j \u0026lt; 5; ++j) { charToCoords[polybiusSquare[i][j]] = {i + 1, j + 1}; // 1-indexed } } charToCoords[\u0026#34;J\u0026#34;] = charToCoords[\u0026#34;I\u0026#34;]; // Handle J as I } std::string polybiusEncrypt(const std::string\u0026amp; plaintext); std::string polybiusDecrypt(const std::string\u0026amp; ciphertext); int main() { initializeMap(); // Initialize the map once std::string message; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 波利比奥斯方阵密码加密/解密程序\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;\\n请输入要处理的消息 (只包含字母): \u0026#34;; std::getline(std::cin, message); std::string encryptedMessage = polybiusEncrypt(message); std::cout \u0026lt;\u0026lt; \u0026#34;\\n加密后的密文是: \u0026#34; \u0026lt;\u0026lt; encryptedMessage \u0026lt;\u0026lt; std::endl; std::string decryptedMessage = polybiusDecrypt(encryptedMessage); std::cout \u0026lt;\u0026lt; \u0026#34;解密后的明文是: \u0026#34; \u0026lt;\u0026lt; decryptedMessage \u0026lt;\u0026lt; std::endl; return 0; } /** * @brief 对给定的文本进行波利比奥斯方阵加密 * @param plaintext 要加密的明文 * @return 加密后的密文 (数字串) */ std::string polybiusEncrypt(const std::string\u0026amp; plaintext) { std::string ciphertext = \u0026#34;\u0026#34;; for (char pChar : plaintext) { pChar = toupper(pChar); // Convert to uppercase for consistency if (isalpha(pChar)) { if (pChar == \u0026#39;J\u0026#39;) pChar = \u0026#39;I\u0026#39;; // Handle J as I if (charToCoords.count(pChar)) { ciphertext += std::to_string(charToCoords[pChar].first); ciphertext += std::to_string(charToCoords[pChar].second); } } else { ciphertext += pChar; // Non-alphabet characters remain unchanged } } return ciphertext; } /** * @brief 对给定的密文进行波利比奥斯方阵解密 * @param ciphertext 要解密的密文 (数字串) * @return 解密后的明文 */ std::string polybiusDecrypt(const std::string\u0026amp; ciphertext) { std::string plaintext = \u0026#34;\u0026#34;; for (size_t i = 0; i \u0026lt; ciphertext.length(); i += 2) { if (isdigit(ciphertext[i]) \u0026amp;\u0026amp; isdigit(ciphertext[i+1])) { int row = ciphertext[i] - \u0026#39;0\u0026#39;; int col = ciphertext[i+1] - \u0026#39;0\u0026#39;; if (row \u0026gt;= 1 \u0026amp;\u0026amp; row \u0026lt;= 5 \u0026amp;\u0026amp; col \u0026gt;= 1 \u0026amp;\u0026amp; col \u0026lt;= 5) { plaintext += polybiusSquare[row - 1][col - 1]; // Convert back to 0-indexed } } else { // Handle non-digit characters (e.g., spaces) that were not encrypted plaintext += ciphertext[i]; if (i + 1 \u0026lt; ciphertext.length()) { plaintext += ciphertext[i+1]; } i -= 1; // Adjust index for single non-digit char or pair } } return plaintext; } ","date":"2025-08-14T17:34:00+08:00","permalink":"http://localhost:1313/post/programmingtechnology/classicalcryptography/polybius/","title":"波利比奥斯方阵密码"},{"content":"前言：为什么钱包选择至关重要？ 在 Web3 和加密货币的世界里，你的钱包就是你的银行账户、身份凭证和保险箱。与传统银行不同，这里没有客服电话可以帮你重置密码或追回被盗资金。你必须成为自己资产的唯一守护者。因此，选择一个安全可靠的钱包，是进入这个领域最重要的一步。\n钱包的核心：热钱包 vs. 冷钱包 在讨论具体类型之前，我们首先需要理解两个核心概念：热钱包和冷钱包。它们的根本区别在于私钥（访问你资产的唯一钥匙）是否接触互联网。\n热钱包 (Hot Wallet): 指的是私钥存储在联网设备上的钱包，如手机 App 或浏览器插件。\n优点: 使用方便，适合日常交易和与 DApp 交互。 缺点: 始终在线，容易成为黑客攻击的目标，安全性相对较低。 冷钱包 (Cold Wallet): 指的是私钥离线存储的钱包，只有在签名交易时才短暂连接设备。\n优点: 物理隔离，安全性极高，是存储大额或长期持有资产的最佳选择。 缺点: 操作相对繁琐，不适合高频交易。 主流钱包类型深度解析 了解了冷热之分后，我们再来看市面上主流的三种钱包形态。\n软件钱包 (Software Wallet) - 便捷的热钱包 软件钱包是最常见的钱包类型，通常以桌面应用、浏览器插件或手机 App 的形式存在。\n优点: 极致便捷: 安装即可使用，转账、收款、与 DApp 交互都非常流畅。 免费: 大部分软件钱包都是免费的。 功能丰富: 通常集成了 DApp 浏览器、行情查看、多链支持等功能。 缺点: 安全风险高: 由于设备始终联网，面临的攻击面最广。常见的风险包括： 木马病毒: 电脑或手机中毒，私钥或助记词被窃取。 钓鱼攻击: 访问了假的网站或 App，授权了恶意合约。 供应链攻击: 下载了被篡改的钱包应用。 适用场景: 存放少量资金，用于日常小额交易和探索 Web3 应用。 代表产品: MetaMask, Trust Wallet, Phantom 硬件钱包 (Hardware Wallet) - 最均衡的冷钱包 硬件钱包是一个专门设计用于存储私钥的物理设备，外形类似 U 盘。它通过将签名过程隔离在设备内部，实现了极高的安全性。\n优点: 安全性高: 私钥永不离开硬件设备，即使连接了中毒的电脑，资产依然安全。 物理确认: 所有交易都需要在设备上按下物理按键进行确认，有效防止远程攻击。 资产掌控感强: 让你真正拥有自己的私钥。 缺点: 需要购买: 价格从几百到上千元不等。 操作稍繁琐: 每次交易都需要连接设备并进行物理确认。 （极低概率）供应链风险: 理论上存在设备在生产或运输环节被植入后门的风险，因此务必从官方渠道购买。 适用场景: 存储大额资产，或作为长期投资的安全保障。 代表产品: Ledger, Trezor, OneKey 纸钱包 (Paper Wallet) - 极致安全的冷钱包 纸钱包本质上就是将你的公钥（地址）和私钥打印在一张纸上。这是一种最原始、最彻底的离线存储方式。\n优点: 安全性极高: 完全物理隔离，只要纸张本身安全，资产就绝对安全。 零成本: 你只需要一台安全的电脑和一台打印机。 缺点: 极其脆弱: 纸张容易因火灾、水浸、褪色等原因损毁，导致资产永久丢失。 操作极不方便: 使用时需要将私钥导入软件钱包，这会使其“变热”，通常是一次性使用。 易操作失误: 创建和使用过程对新手不友好，容易出错。 适用场景: 适合作为“传家宝”式的长期、深度存储，且使用者具备足够的安全知识。 总结与建议 钱包类型 安全性 便捷性 成本 核心风险 推荐用途 软件钱包 ★☆☆☆☆ ★★★★★ 免费 木马、钓鱼、网络攻击 小额、高频交易 硬件钱包 ★★★★☆ ★★★☆☆ 较高 物理丢失、供应链攻击 大额、长期存储 纸钱包 ★★★★★ ★☆☆☆☆ 极低 物理损坏、丢失 终极离线备份 给新手的建议：\n组合使用: 不要把所有鸡蛋放在一个篮子里。使用一个硬件钱包存储你的大部分资产，再用一个软件钱包存放少量资金用于日常交互。 助记词是生命: 无论使用哪种钱包，物理备份并妥善保管你的助记词（通常是12或24个单词）。不要截图、不要发邮件、不要存云盘！ 从官方渠道下载/购买: 永远只从官网或官方应用商店获取钱包应用和硬件设备。 希望这篇文章能帮助你迈出安全进入加密世界的第一步。\n","date":"2025-08-14T17:10:00+08:00","permalink":"http://localhost:1313/post/cryptocurrency/choosewallet/","title":"选择钱包"},{"content":"什么是一次性密码本？ 一次性密码本（One-Time Pad, OTP），又称“一次一密”，是古典密码学中一种理论上被证明绝对安全的加密算法。它由美国电话电报公司的吉尔伯特·维纳姆（Gilbert Vernam）于1917年发明，并由克劳德·香农（Claude Shannon）在信息论中证明了其不可破译性。\n一次性密码本的核心思想是使用一个与明文等长、完全随机且只使用一次的密钥。加密过程是将明文与密钥进行逐位（或逐字符）的异或（XOR）运算。由于密钥的随机性、等长性和一次性，即使攻击者截获了密文，也无法从中获取任何关于明文的信息。\n一次性密码本的三个核心条件：\n密钥必须是真正随机的： 密钥的生成必须是完全不可预测的，不能有任何模式或可重复性。 密钥必须与明文等长： 密钥的长度必须至少与要加密的明文长度相同。 密钥必须只使用一次： 每个密钥只能用于加密一条消息，之后必须立即销毁，不能重复使用。 如果这三个条件都得到满足，那么一次性密码本是唯一一种被数学证明为绝对安全的加密方案。任何密文都可能对应任何明文，因为存在一个密钥可以将密文转换为任何可能的明文，这使得攻击者无法区分真实的明文。\n加密示例 (以字母为例，A=0, B=1, \u0026hellip;, Z=25):\n假设明文为 HELLO，密钥为 XMCKL。\n明文 (P) H (7) E (4) L (11) L (11) O (14) 密钥 (K) X (23) M (12) C (2) K (10) L (11) 加密 (P+K mod 26) (7+23)%26=4 (E) (4+12)%26=16 (Q) (11+2)%26=13 (N) (11+10)%26=21 (V) (14+11)%26=25 (Z) 密文 (C) E Q N V Z 明文 (Plaintext): HELLO 密钥 (Key): XMCKL 密文 (Ciphertext): EQNVZ 一次性密码本的数学表示 一次性密码本的数学表示通常使用异或（XOR）运算，尤其是在二进制层面。如果我们将明文和密钥都视为二进制序列，那么加密和解密过程可以表示为：\n设：\nP 为明文（二进制序列）。 K 为密钥（二进制序列）。 C 为密文（二进制序列）。 那么，加密过程可以表示为： $$ C = P \\oplus K $$\n解密过程则是： $$ P = C \\oplus K $$\n其中 $\\oplus$ 表示异或运算。异或运算的特性是 A \\oplus B \\oplus B = A，这使得加密和解密可以使用相同的操作。当明文和密钥都是字母时，我们可以将它们转换为数字（例如，A=0, B=1, \u0026hellip;, Z=25），然后进行模加运算，这与异或运算在概念上是相似的。\n设：\nP_i 为明文的第 i 个字母对应的数字。 K_i 为密钥的第 i 个字母对应的数字。 C_i 为密文的第 i 个字母对应的数字。 那么，加密过程可以表示为： $$ C_i = (P_i + K_i) \\pmod{26} $$\n解密过程则是： $$ P_i = (C_i - K_i + 26) \\pmod{26} $$\n这里的 mod 26 (模26) 运算确保了结果在 0 到 25 之间，并且处理了负数的情况。\n一次性密码本为何不可破译？ 一次性密码本之所以被认为是理论上绝对安全的，其核心在于满足了香农的**完美保密性（Perfect Secrecy）**定义。完美保密性意味着，给定密文，攻击者无法获得任何关于明文的信息，即密文不泄露任何明文信息。\n具体来说，一次性密码本的不可破译性基于以下几点：\n密钥的完全随机性： 密钥是真正随机生成的，这意味着密钥中的每一个位（或字符）都是独立且均匀分布的。攻击者无法通过任何统计方法或模式分析来预测密钥的下一个部分。\n密钥与明文等长： 密钥的长度与明文完全相同。这保证了密钥的每一个部分都只用于加密明文的对应部分，没有重复使用。\n密钥的一次性使用： 密钥只使用一次。这是最关键的条件。如果密钥被重复使用，即使是随机生成的，也会引入可分析的模式，从而导致密码被破解（例如，通过异或两个使用相同密钥加密的密文，可以得到两个明文的异或结果，从而进行频率分析）。\n密文的均匀分布： 当密钥是完全随机且与明文等长时，生成的密文也是完全随机且均匀分布的。这意味着，对于任何给定的密文，所有可能的明文都以相同的概率对应这个密文。攻击者无法通过分析密文的统计特性来推断出原始明文的任何信息。\n举例来说，如果密文是 X，攻击者不知道明文是 A 还是 B。如果明文是 A，那么密钥必须是 K_A 才能生成 X；如果明文是 B，那么密钥必须是 K_B 才能生成 X。由于密钥是完全随机的，K_A 和 K_B 都是同样可能的密钥。因此，攻击者无法区分明文是 A 还是 B，因为两种情况都同样符合逻辑。\n正是由于这些严格的条件，一次性密码本在理论上提供了无条件的安全。然而，在实际应用中，生成、分发和管理真正随机且只使用一次的等长密钥是非常困难和昂贵的，这限制了其大规模应用。它主要用于高度机密的通信，例如外交和军事领域。\nC++ 代码实现 下面是一个简单的 C++ 程序，它演示了一次性密码本的加密和解密功能。请注意，在实际应用中，密钥的生成和管理会更加复杂，以确保其真正的随机性和一次性。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;random\u0026gt; #include \u0026lt;chrono\u0026gt; // Function to generate a random key of a given length std::string generateRandomKey(int length) { std::string key = \u0026#34;\u0026#34;; // Use a random device to seed the random number generator std::random_device rd; // Use the Mersenne Twister engine std::mt19937 gen(rd()); // Define a distribution for characters (e.g., \u0026#39;A\u0026#39; to \u0026#39;Z\u0026#39;) std::uniform_int_distribution\u0026lt;\u0026gt; distrib(0, 25); // 0-25 for A-Z for (int i = 0; i \u0026lt; length; ++i) { key += static_cast\u0026lt;char\u0026gt;(\u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;[distrib(gen)]); } return key; } // Function to convert a character to its 0-25 integer equivalent int charToInt(char c) { if (isupper(c)) { return c - \u0026#39;A\u0026#39;; } else if (islower(c)) { return c - \u0026#39;a\u0026#39;; } return -1; // Not an alphabet character } // Function to convert an integer (0-25) back to a character char intToChar(int i, char originalCase) { if (isupper(originalCase)) { return static_cast\u0026lt;char\u0026gt;(\u0026#39;A\u0026#39; + i); } else { return static_cast\u0026lt;char\u0026gt;(\u0026#39;a\u0026#39; + i); } } std::string oneTimePadEncrypt(const std::string\u0026amp; plaintext, const std::string\u0026amp; key); std::string oneTimePadDecrypt(const std::string\u0026amp; ciphertext, const std::string\u0026amp; key); int main() { std::string message; std::string key; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 一次性密码本加密/解密程序\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;\\n请输入要处理的消息 (只包含字母): \u0026#34;; std::getline(std::cin, message); // Generate a random key of the same length as the message key = generateRandomKey(message.length()); std::cout \u0026lt;\u0026lt; \u0026#34;生成的密钥是: \u0026#34; \u0026lt;\u0026lt; key \u0026lt;\u0026lt; std::endl; std::string encryptedMessage = oneTimePadEncrypt(message, key); std::cout \u0026lt;\u0026lt; \u0026#34;\\n加密后的密文是: \u0026#34; \u0026lt;\u0026lt; encryptedMessage \u0026lt;\u0026lt; std::endl; std::string decryptedMessage = oneTimePadDecrypt(encryptedMessage, key); std::cout \u0026lt;\u0026lt; \u0026#34;解密后的明文是: \u0026#34; \u0026lt;\u0026lt; decryptedMessage \u0026lt;\u0026lt; std::endl; return 0; } /** * @brief 对给定的文本进行一次性密码本加密 * @param plaintext 要加密的明文 * @param key 密钥 (与明文等长，完全随机) * @return 加密后的密文 */ std::string oneTimePadEncrypt(const std::string\u0026amp; plaintext, const std::string\u0026amp; key) { std::string ciphertext = \u0026#34;\u0026#34;; for (size_t i = 0; i \u0026lt; plaintext.length(); ++i) { if (isalpha(plaintext[i])) { int pVal = charToInt(plaintext[i]); int kVal = charToInt(key[i]); int cVal = (pVal + kVal) % 26; ciphertext += intToChar(cVal, plaintext[i]); } else { ciphertext += plaintext[i]; } } return ciphertext; } /** * @brief 对给定的文本进行一次性密码本解密 * @param ciphertext 要解密的密文 * @param key 密钥 (与密文等长，完全随机) * @return 解密后的明文 */ std::string oneTimePadDecrypt(const std::string\u0026amp; ciphertext, const std::string\u0026amp; key) { std::string plaintext = \u0026#34;\u0026#34;; for (size_t i = 0; i \u0026lt; ciphertext.length(); ++i) { if (isalpha(ciphertext[i])) { int cVal = charToInt(ciphertext[i]); int kVal = charToInt(key[i]); int pVal = (cVal - kVal + 26) % 26; // Add 26 to handle negative results of modulo plaintext += intToChar(pVal, ciphertext[i]); } else { plaintext += ciphertext[i]; } } return plaintext; } ","date":"2025-08-13T23:41:29+08:00","permalink":"http://localhost:1313/post/programmingtechnology/classicalcryptography/one-timepad/","title":"一次性密码本"},{"content":"什么是维吉尼亚密码？ 维吉尼亚密码（Vigenère cipher）是一种多表替换密码（Polyalphabetic Substitution Cipher），它使用一系列凯撒密码组成密码字母表。与凯撒密码（单表替换密码）不同，维吉尼亚密码的加密不再是简单的固定移位，而是根据一个**密钥（Keyword）**的字母来决定每个明文字母的移位量。\n维吉尼亚密码在16世纪由意大利外交官吉奥万·巴蒂斯塔·贝拉索（Giovan Battista Bellaso）发明，但后来被误认为是法国密码学家布莱斯·德·维吉尼亚（Blaise de Vigenère）的发明，因此得名。它在密码学史上具有重要地位，因为它在很长一段时间内被认为是不可破解的，被称为“不可破译的密码”（le chiffre indéchiffrable）。\n工作原理：\n维吉尼亚密码的核心思想是使用一个密钥单词。密钥单词的每个字母决定了明文对应位置字母的移位量。当密钥单词的长度不足以覆盖整个明文时，密钥会重复使用。\n例如，如果密钥是 KEY，明文是 ATTACKATDAWN：\n重复密钥： 将密钥重复，使其长度与明文相同。 明文: ATTACKATDAWN 密钥: KEYKEYKEYKEY\n逐字母加密： 每个明文字母根据其对应密钥字母的移位量进行凯撒加密。\n明文 A (0) 对应密钥 K (10)。 A 移位 10 位变成 K。 明文 T (19) 对应密钥 E (4)。 T 移位 4 位变成 X。 明文 T (19) 对应密钥 Y (24)。 T 移位 24 位变成 R。 以此类推。 加密示例:\n明文 (Plaintext): ATTACKATDAWN 密钥 (Key): LEMON 重复密钥: LEMONLEMONLE 密文 (Ciphertext): LXFOPVEFRNHR 维吉尼亚密码的数学表示 维吉尼亚密码的加密和解密可以利用模运算来表示。我们将字母表中的每个字母映射为一个数字（例如，A=0, B=1, \u0026hellip;, Z=25）。\n设：\nP_i 为明文的第 i 个字母对应的数字。 C_i 为密文的第 i 个字母对应的数字。 K_i 为密钥的第 i 个字母对应的数字（密钥循环使用）。 那么，加密过程可以表示为： $$ C_i = (P_i + K_i) \\pmod{26} $$\n解密过程则是加密的逆运算： $$ P_i = (C_i - K_i + 26) \\pmod{26} $$\n这里的 mod 26 (模26) 运算确保了结果在 0 到 25 之间，并且处理了负数的情况。例如，当明文 A (0) 遇到密钥 L (11) 时： C = (0 + 11) mod 26 = 11，对应的字母是 L。\n当明文 T (19) 遇到密钥 E (4) 时： C = (19 + 4) mod 26 = 23，对应的字母是 X。\n如何破解维吉尼亚密码？ 尽管维吉尼亚密码在很长一段时间内被认为是不可破解的，但它并非绝对安全。相比于凯撒密码和阿特巴希密码，维吉尼亚密码的破解难度大大增加，因为它引入了多表替换，使得简单的频率分析不再有效。然而，如果攻击者能够确定密钥的长度，那么维吉尼亚密码就可以被分解成多个凯撒密码进行破解。\n1. 确定密钥长度 这是破解维吉尼亚密码最关键的一步。一旦密钥长度 L 被确定，密文就可以被分成 L 个子密文，每个子密文都是由一个凯撒密码加密的。常用的确定密钥长度的方法有：\na. 卡西斯基考试法 (Kasiski Examination) 卡西斯基考试法通过寻找密文中重复出现的字母序列来推测密钥长度。如果一个重复的字母序列在明文中出现，并且它们之间的距离是密钥长度的整数倍，那么在密文中它们也会以相同的形式重复出现。通过计算这些重复序列之间距离的最大公约数（GCD），可以得到密钥长度的可能值。\n例如，如果密文中“ABC”重复出现，第一次在位置5，第二次在位置15，那么它们之间的距离是10。如果“XYZ”重复出现，第一次在位置8，第二次在位置28，距离是20。那么密钥长度可能是10和20的公约数，即10或5或2或1。\nb. 重合指数法 (Index of Coincidence, IC) 重合指数是衡量一段文本中任意两个随机选择的字母相同的概率。对于英文文本，其重合指数约为0.067。对于随机文本或均匀分布的文本，其重合指数约为0.038。\n维吉尼亚密码的破解可以利用重合指数。攻击者可以尝试不同的密钥长度 L，将密文分成 L 个子密文。如果假设的密钥长度是正确的，那么每个子密文都将是一个凯撒密码加密的文本，其重合指数应该接近英文的0.067。通过计算不同假设密钥长度下的子密文的重合指数，最接近0.067的那个长度很可能就是真实的密钥长度。\n2. 频率分析破解子密文 一旦密钥长度 L 被确定，密文就被分解成了 L 个独立的凯撒密码。每个子密文都可以使用频率分析法（与破解凯撒密码相同的方法）来单独破解。通过分析每个子密文的字母频率分布，并与英文的字母频率分布进行比较，可以确定每个子密文的移位量，从而推导出密钥的每个字母。\n3. 组合密钥并解密 当所有子密文的移位量都被确定后，就可以组合这些移位量来得到完整的密钥。然后，使用这个密钥对原始密文进行解密，即可恢复明文。\n尽管维吉尼亚密码比凯撒密码更复杂，但它仍然是古典密码学的一部分，在现代密码学中已经不再安全。现代密码学使用更复杂的算法和更长的密钥来确保信息的安全性。\nC++ 代码实现 下面是一个完整的 C++ 程序，它实现了维吉尼亚密码的加密和解密功能。代码结构清晰，并包含了详细的注释。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cctype\u0026gt; // Function to convert a character to its 0-25 integer equivalent int charToInt(char c) { if (isupper(c)) { return c - \u0026#39;A\u0026#39;; } else if (islower(c)) { return c - \u0026#39;a\u0026#39;; } return -1; // Not an alphabet character } // Function to convert an integer (0-25) back to a character char intToChar(int i, char originalCase) { if (isupper(originalCase)) { return static_cast\u0026lt;char\u0026gt;(\u0026#39;A\u0026#39; + i); } else { return static_cast\u0026lt;char\u0026gt;(\u0026#39;a\u0026#39; + i); } } std::string vigenereEncrypt(const std::string\u0026amp; plaintext, const std::string\u0026amp; key); std::string vigenereDecrypt(const std::string\u0026amp; ciphertext, const std::string\u0026amp; key); int main() { std::string message; std::string key; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 维吉尼亚密码加密/解密程序\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;\\n请输入要处理的消息: \u0026#34;; std::getline(std::cin, message); std::cout \u0026lt;\u0026lt; \u0026#34;请输入密钥 (只包含字母): \u0026#34;; std::getline(std::cin, key); // Convert key to uppercase for consistent processing for (char \u0026amp;c : key) { c = toupper(c); } std::string encryptedMessage = vigenereEncrypt(message, key); std::cout \u0026lt;\u0026lt; \u0026#34;\\n加密后的密文是: \u0026#34; \u0026lt;\u0026lt; encryptedMessage \u0026lt;\u0026lt; std::endl; std::string decryptedMessage = vigenereDecrypt(encryptedMessage, key); std::cout \u0026lt;\u0026lt; \u0026#34;解密后的明文是: \u0026#34; \u0026lt;\u0026lt; decryptedMessage \u0026lt;\u0026lt; std::endl; return 0; } /** * @brief 对给定的文本进行维吉尼亚加密 * @param plaintext 要加密的明文 * @param key 密钥 * @return 加密后的密文 */ std::string vigenereEncrypt(const std::string\u0026amp; plaintext, const std::string\u0026amp; key) { std::string ciphertext = \u0026#34;\u0026#34;; int keyIndex = 0; for (char pChar : plaintext) { if (isalpha(pChar)) { int pVal = charToInt(pChar); int kVal = charToInt(key[keyIndex % key.length()]); int cVal = (pVal + kVal) % 26; ciphertext += intToChar(cVal, pChar); keyIndex++; } else { ciphertext += pChar; } } return ciphertext; } /** * @brief 对给定的文本进行维吉尼亚解密 * @param ciphertext 要解密的密文 * @param key 密钥 * @return 解密后的明文 */ std::string vigenereDecrypt(const std::string\u0026amp; ciphertext, const std::string\u0026amp; key) { std::string plaintext = \u0026#34;\u0026#34;; int keyIndex = 0; for (char cChar : ciphertext) { if (isalpha(cChar)) { int cVal = charToInt(cChar); int kVal = charToInt(key[keyIndex % key.length()]); int pVal = (cVal - kVal + 26) % 26; // Add 26 to handle negative results of modulo plaintext += intToChar(pVal, cChar); keyIndex++; } else { plaintext += cChar; } } return plaintext; } ","date":"2025-08-13T23:36:51+08:00","permalink":"http://localhost:1313/post/programmingtechnology/classicalcryptography/vigenerecipher/","title":"维吉尼亚密码"},{"content":"什么是ROT13密码？ ROT13（“rotate by 13 places”的缩写，意为“循环左移13位”）是一种替换密码（Substitution Cipher），它是凯撒密码的一种特殊形式。它的加密过程非常简单：将明文中的每一个字母，用字母表上向后移动13位的另一个字母来替换。\n由于英文字母表共有26个字母，而13正好是26的一半，这意味着对一个字母进行两次ROT13加密，就会回到原始字母。因此，ROT13既可以用于加密，也可以用于解密。\n例如，如果我们选择的移位量是 13，那么：\n字母 A 会被替换成字母表中向后移动 13 位的 N。 字母 B 会被替换成 O。 \u0026hellip; 字母 M 会被替换成 Z。 字母 N 会被替换成 A。 \u0026hellip; 字母 Z 会被替换成 M。 这个过程就像是将整个字母表向左平移了 13 位，形成了一个新的对应关系。\n加密示例:\n明文 (Plaintext): HELLO WORLD 密文 (Ciphertext): URYYB JBEYQ ROT13密码的数学表示 ROT13密码的数学表示与凯撒密码类似。我们将字母表中的每个字母映射为一个数字（例如，A=0, B=1, \u0026hellip;, Z=25）。\n设：\nP 为明文字母对应的数字。 C 为密文字母对应的数字。 k 为移位量，对于ROT13，k 固定为 13。 那么，加密过程可以表示为： $$ C = (P + 13) \\pmod{26} $$\n解密过程与加密过程相同，因为 (X + 13 + 13) mod 26 = (X + 26) mod 26 = X mod 26： $$ P = (C + 13) \\pmod{26} $$\n这里的 mod 26 (模26) 运算是关键，它完美地实现了字母表的循环。例如，当加密 A (0) 时： C = (0 + 13) mod 26 = 13 mod 26 = 13，对应的字母是 N。\n当加密 N (13) 时： C = (13 + 13) mod 26 = 26 mod 26 = 0，对应的字母是 A。\n如何“破解”ROT13密码？ ROT13密码的安全性极低，因为它本质上就是一种固定密钥的凯撒密码。它的“破解”方法非常简单，甚至可以说不需要破解，只需要再次应用ROT13算法即可。\n1. 再次应用ROT13算法 由于ROT13的移位量是13，而英文字母表有26个字母，13正好是26的一半。这意味着对一个字母进行两次ROT13加密操作，就会回到原始字母。例如，A 经过ROT13变成 N，N 再次经过ROT13又变回 A。因此，加密和解密使用相同的算法。\n这意味着，任何知道ROT13算法的人，都可以轻易地将ROT13加密的文本解密出来。它通常不用于保护敏感信息，而是用于隐藏一些剧透、谜题答案或不雅内容，以避免无意中看到。\n2. 频率分析 (Frequency Analysis) 虽然可以直接解密，但频率分析仍然可以用于识别文本是否经过ROT13加密。如果密文的字母频率分布与原始语言的频率分布呈现出13位的偏移，那么很可能就是ROT13加密。例如，如果密文中出现频率最高的字母是 N，而明文中最常见的字母是 E，那么 N 到 E 的偏移量正好是13（反向），这可以作为ROT13的证据。\nC++ 代码实现 下面是一个完整的 C++ 程序，它实现了ROT13密码的加密和解密功能。代码结构清晰，并包含了详细的注释。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cctype\u0026gt; std::string rot13Cipher(const std::string\u0026amp; text); int main() { std::string message; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; ROT13密码加密/解密程序\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;\\n请输入要处理的消息: \u0026#34;; std::getline(std::cin, message); std::string processedMessage = rot13Cipher(message); std::cout \u0026lt;\u0026lt; \u0026#34;\\n处理后的消息是: \u0026#34; \u0026lt;\u0026lt; processedMessage \u0026lt;\u0026lt; std::endl; return 0; } /** * @brief 对给定的文本进行ROT13加密或解密 * @param text 要处理的文本 * @return 处理后的文本 */ std::string rot13Cipher(const std::string\u0026amp; text) { std::string result = \u0026#34;\u0026#34;; for (char c : text) { if (isalpha(c)) { char base = isupper(c) ? \u0026#39;A\u0026#39; : \u0026#39;a\u0026#39;; // Apply ROT13 formula: (P + 13) % 26 result += static_cast\u0026lt;char\u0026gt;(base + (c - base + 13) % 26); } else { result += c; } } return result; } ","date":"2025-08-13T23:28:33+08:00","permalink":"http://localhost:1313/post/programmingtechnology/classicalcryptography/rot13cipher/","title":"ROT13密码"},{"content":"什么是阿特巴希密码？ 阿特巴希密码（Atbash Cipher）是一种替换密码（Substitution Cipher），也是已知最早的密码系统之一。它的加密原理非常简单：将字母表中的第一个字母替换为最后一个字母，第二个字母替换为倒数第二个字母，以此类推，形成一种反向的映射关系。\n例如，在拉丁字母表中：\n字母 A 会被替换成 Z。 字母 B 会被替换成 Y。 \u0026hellip; 字母 M 会被替换成 N。 字母 N 会被替换成 M。 \u0026hellip; 字母 Z 会被替换成 A。 这种替换是固定的，不需要密钥，因为其替换规则本身就是固定的“密钥”。\n加密示例:\n明文 (Plaintext): HELLO WORLD 密文 (Ciphertext): SVOOL DLIOW 阿特巴希密码的数学表示 阿特巴希密码的数学表示也相对简单。我们将字母表中的每个字母映射为一个数字（例如，A=0, B=1, \u0026hellip;, Z=25）。\n设：\nP 为明文字母对应的数字。 C 为密文字母对应的数字。 那么，加密过程可以表示为： $$ C = (25 - P) \\pmod{26} $$\n解密过程与加密过程相同，因为阿特巴希密码是对称的： $$ P = (25 - C) \\pmod{26} $$\n这里的 mod 26 (模26) 运算确保了结果在 0 到 25 之间。例如，当加密 A (0) 时： C = (25 - 0) mod 26 = 25 mod 26 = 25，对应的字母是 Z。\n当加密 Z (25) 时： C = (25 - 25) mod 26 = 0 mod 26 = 0，对应的字母是 A。\n如何破解阿特巴希密码？ 阿特巴希密码的安全性极低，甚至比凯撒密码还要低。因为它没有密钥，加密规则是固定的，所以一旦知道是阿特巴希密码，就可以直接解密。\n1. 直接解密 由于阿特巴希密码的加密和解密规则是相同的，且是公开的（A对Z，B对Y等），因此不需要任何密钥。攻击者一旦识别出这是阿特巴希密码，就可以直接应用其反向映射规则进行解密。\n2. 频率分析 (Frequency Analysis) 尽管可以直接解密，但频率分析仍然可以用于确认是否为阿特巴希密码。在任何一种自然语言中，不同字母的出现频率是有统计规律的。通过分析密文中字母的频率分布，并将其与已知语言的字母频率分布进行比较，可以推断出密文是否由阿特巴希密码加密。例如，如果密文中出现频率最高的字母对应到明文中的字母E（英语中最常见的字母），则可以进一步确认。\nC++ 代码实现 下面是一个完整的 C++ 程序，它实现了阿特巴希密码的加密和解密功能。代码结构清晰，并包含了详细的注释。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cctype\u0026gt; std::string atbashCipher(const std::string\u0026amp; text); int main() { std::string message; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 阿特巴希密码加密/解密程序\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;\\n请输入要处理的消息: \u0026#34;; std::getline(std::cin, message); std::string processedMessage = atbashCipher(message); std::cout \u0026lt;\u0026lt; \u0026#34;\\n处理后的消息是: \u0026#34; \u0026lt;\u0026lt; processedMessage \u0026lt;\u0026lt; std::endl; return 0; } /** * @brief 对给定的文本进行阿特巴希加密或解密 * @param text 要处理的文本 * @return 处理后的文本 */ std::string atbashCipher(const std::string\u0026amp; text) { std::string result = \u0026#34;\u0026#34;; for (char c : text) { if (isalpha(c)) { char base = isupper(c) ? \u0026#39;A\u0026#39; : \u0026#39;a\u0026#39;; // Apply Atbash formula: C = (25 - P) or P = (25 - C) result += static_cast\u0026lt;char\u0026gt;(base + (25 - (c - base))); } else { result += c; } } return result; } ","date":"2025-08-13T23:13:40+08:00","permalink":"http://localhost:1313/post/programmingtechnology/classicalcryptography/atbashcipher/","title":"阿特巴希密码"},{"content":"什么是仿射密码？ 仿射密码是一种替换密码（Substitution Cipher），它是凯撒密码的扩展，引入了更为复杂的数学运算。与凯撒密码仅仅通过加法进行位移不同，仿射密码结合了乘法和加法的线性变换。其核心在于将字母表中的每个字母映射到一个数值（通常A=0，B=1，\u0026hellip;，Z=25），然后通过一个仿射函数进行变换，最后再将变换后的数值映射回字母。\n仿射密码的数学表示 仿射密码的加密和解密过程都可以用数学语言精确地描述。我们将字母表中的每个字母映射为一个数字（例如，A=0, B=1, \u0026hellip;, Z=25）。\n加密函数 仿射密码的加密函数定义为：\n$$E(x) = (ax + b) \\pmod{m}$$\n其中：\nx 代表明文字母对应的数值（0到 m-1）。 a 和 b 是密钥，其中 a 必须与 m 互质（即它们的最大公约数为1）。 m 是字母表中的字母数量，对于英文字母表，m 通常取26。 E(x) 代表密文字母对应的数值。 互质条件的重要性： a 与 m 互质是仿射密码能够成功解密的必要条件。如果 a 和 m 不互质，那么在加密过程中可能会出现不同的明文字母加密后得到相同的密文字母的情况，导致解密时无法唯一确定原始明文，从而无法正确解密。\n解密函数 解密是加密的逆过程。为了从密文 y 恢复明文 x，我们需要找到加密函数 E(x) = (ax + b) mod m 的逆函数。从加密函数可以推导出：\n$$y \\equiv ax + b \\pmod{m}$$ $$y - b \\equiv ax \\pmod{m}$$\n为了解出 x，我们需要找到 a 在模 m 意义下的乘法逆元 a^-1，即满足 (a * a^-1) mod m = 1 的 a^-1。只有当 a 与 m 互质时，a^-1 才存在。\n解密函数定义为：\n$$D(y) = a^{-1}(y - b) \\pmod{m}$$\n其中：\ny 代表密文字母对应的数值。 a^-1 是 a 在模 m 意义下的乘法逆元。 b 是加密时使用的密钥 b。 D(y) 代表解密后明文字母对应的数值。 寻找乘法逆元： 乘法逆元 a^-1 可以通过扩展欧几里得算法或穷举法（对于较小的 m 值，如26）来找到。例如，当 m=26 时，与26互质的 a 值有1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25。每个 a 值都有其对应的唯一乘法逆元。\n示例 假设我们使用英文字母表（m=26），密钥 a=5，b=8。由于5和26互质，这是一个有效的密钥对。\n加密“HELLO”：\n将明文字母转换为数值： H -\u0026gt; 7 E -\u0026gt; 4 L -\u0026gt; 11 L -\u0026gt; 11 O -\u0026gt; 14\n应用加密函数 E(x) = (5x + 8) mod 26： H: E(7) = (57 + 8) mod 26 = (35 + 8) mod 26 = 43 mod 26 = 17 -\u0026gt; R E: E(4) = (54 + 8) mod 26 = (20 + 8) mod 26 = 28 mod 26 = 2 -\u0026gt; C L: E(11) = (511 + 8) mod 26 = (55 + 8) mod 26 = 63 mod 26 = 11 -\u0026gt; L L: E(11) = (511 + 8) mod 26 = (55 + 8) mod 26 = 63 mod 26 = 11 -\u0026gt; L O: E(14) = (5*14 + 8) mod 26 = (70 + 8) mod 26 = 78 mod 26 = 0 -\u0026gt; A\n加密后的密文是 RCLLA。\n解密“RCLLA”：\n首先找到 a=5 在模26下的乘法逆元 a^-1。我们需要找到一个数 x 使得 5x mod 26 = 1。通过计算可知 5 * 21 = 105，105 mod 26 = 1，所以 a^-1 = 21。\n将密文字母转换为数值： R -\u0026gt; 17 C -\u0026gt; 2 L -\u0026gt; 11 L -\u0026gt; 11 A -\u0026gt; 0\n应用解密函数 D(y) = 21(y - 8) mod 26： R: D(17) = 21(17 - 8) mod 26 = 21 * 9 mod 26 = 189 mod 26 = 7 -\u0026gt; H C: D(2) = 21(2 - 8) mod 26 = 21 * (-6) mod 26 = -126 mod 26 = 10 * 26 - 126 mod 26 = 4 -\u0026gt; E L: D(11) = 21(11 - 8) mod 26 = 21 * 3 mod 26 = 63 mod 26 = 11 -\u0026gt; L L: D(11) = 21(11 - 8) mod 26 = 21 * 3 mod 26 = 63 mod 26 = 11 -\u0026gt; L A: D(0) = 21(0 - 8) mod 26 = 21 * (-8) mod 26 = -168 mod 26 = 10 * 26 - 168 mod 26 = 260 - 168 mod 26 = 92 mod 26 = 14 -\u0026gt; O\n解密后的明文是 HELLO。\nC++ 代码实现 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;numeric\u0026gt; int modInverse(int a, int m) { a = a % m; for (int x = 1; x \u0026lt; m; x++) { if ((a * x) % m == 1) { return x; } } return -1; } bool isCoprime(int a) { return std::gcd(a, 26) == 1; } std::string encryptAffine(const std::string\u0026amp; text, int a, int b) { std::string result = \u0026#34;\u0026#34;; for (char c : text) { if (isalpha(c)) { char base = islower(c) ? \u0026#39;a\u0026#39; : \u0026#39;A\u0026#39;; int x = c - base; result += static_cast\u0026lt;char\u0026gt;(((a * x + b) % 26) + base); } else { result += c; } } return result; } std::string decryptAffine(const std::string\u0026amp; text, int a, int b) { std::string result = \u0026#34;\u0026#34;; int a_inv = modInverse(a, 26); if (a_inv == -1) { // This case should ideally be handled before calling decrypt return \u0026#34;Error: Modular inverse does not exist. \u0026#39;a\u0026#39; must be coprime to 26.\u0026#34;; } for (char c : text) { if (isalpha(c)) { char base = islower(c) ? \u0026#39;a\u0026#39; : \u0026#39;A\u0026#39;; int y = c - base; // (y - b) might be negative, add 26 to make it positive before modulo result += static_cast\u0026lt;char\u0026gt;(((a_inv * (y - b + 26)) % 26) + base); } else { result += c; } } return result; } int main() { std::string text; int a, b; std::cout \u0026lt;\u0026lt; \u0026#34;请输入要加密的文本: \u0026#34;; std::getline(std::cin, text); std::cout \u0026lt;\u0026lt; \u0026#34;请输入参数 a (必须与 26 互质，例如 1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25): \u0026#34;; std::cin \u0026gt;\u0026gt; a; // Validate \u0026#39;a\u0026#39; while (!isCoprime(a % 26)) { std::cout \u0026lt;\u0026lt; \u0026#34;参数 a 必须与 26 互质。请重新输入: \u0026#34;; std::cin \u0026gt;\u0026gt; a; } a = a % 26; std::cout \u0026lt;\u0026lt; \u0026#34;请输入参数 b (0-25): \u0026#34;; std::cin \u0026gt;\u0026gt; b; b = b % 26; std::string encrypted_text = encryptAffine(text, a, b); std::cout \u0026lt;\u0026lt; \u0026#34;加密后的文本: \u0026#34; \u0026lt;\u0026lt; encrypted_text \u0026lt;\u0026lt; std::endl; std::string decrypted_text = decryptAffine(encrypted_text, a, b); std::cout \u0026lt;\u0026lt; \u0026#34;解密后的文本: \u0026#34; \u0026lt;\u0026lt; decrypted_text \u0026lt;\u0026lt; std::endl; return 0; } 如何破解仿射密码？ 仿射密码的安全性非常低，因为它存在致命的弱点。主要有两种破解方法：\n1. 暴力破解 (Brute-force Attack) 仿射密码的密钥由两个部分组成：a 和 b。对于26个英文字母的字母表（m=26），a 必须与26互质。与26互质的数有12个（1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25）。b 可以是0到25之间的任意整数，有26种可能。因此，仿射密码的总密钥空间大小为 12 * 26 = 312。相较于现代密码学中动辄上百位的密钥长度，312种密钥组合是一个非常小的数字，这使得仿射密码极易受到暴力破解攻击。\n攻击者可以简单地将所有可能的密钥组合全部尝试一遍，直到解密出的文本有意义为止。这个过程对于计算机来说是瞬时完成的。\n2. 频率分析 (Frequency Analysis) 仿射密码属于单表替换密码的范畴，这意味着明文中的每一个特定字母，在加密过程中都会被唯一地替换为密文中的一个特定字母。在任何一种自然语言中，不同字母的出现频率是有统计规律的。例如，在英语中，字母 E 的出现频率最高，其次是 T, A, O 等。\n攻击者可以统计密文中每个字母的出现频率，找到出现次数最多的那个密文字母。它有极大的概率对应明文中的 E。一旦确定了这一对映射关系，就可以结合数学原理推算出密钥 a 和 b，从而破解整个密码。\n仿射密码的特点与应用 仿射密码作为古典密码的一种，具有其独特的特点，这些特点也决定了其在现代密码学中的地位和应用场景。\n特点 单表替换密码： 仿射密码属于单表替换密码的范畴，明文中的每一个特定字母，在加密过程中都会被唯一地替换为密文中的一个特定字母。这种一对一的映射关系是单表替换密码的显著特征。\n与凯撒密码的关系： 凯撒密码可以看作是仿射密码的一种特殊情况。当仿射密码的密钥 a=1 时，加密函数变为 E(x) = (1 * x + b) mod m = (x + b) mod m，这正是凯撒密码的加密函数。因此，凯撒密码是仿射密码的一个子集。\n应用 尽管仿射密码在现代通信中不再用于保护敏感信息，但它在密码学教育和入门领域仍有其价值：\n密码学教学： 仿射密码是理解古典密码原理、加密解密过程以及密钥概念的优秀教学工具。通过学习仿射密码，学生可以直观地了解替换密码的工作方式，以及模运算在密码学中的应用。\n频率分析演示： 仿射密码是演示频率分析攻击原理的理想示例。教师可以通过仿射密码的加密和解密过程，向学生展示如何利用语言的统计特性来破解简单的替换密码。\n编程实践： 实现仿射密码的加密和解密算法是初学者进行密码学编程实践的良好起点。这有助于培养编程技能，并加深对密码学算法的理解。\n历史研究： 作为古典密码的一部分，仿射密码在密码学发展史上占有一席之地。研究仿射密码有助于了解密码学从简单替换到复杂算法的演变过程。\n总而言之，仿射密码虽然在实际应用中已不再具备安全性，但其在密码学教育和历史研究中仍然发挥着重要的作用，为我们理解更复杂的加密技术提供了基础。\n总结 仿射密码作为古典密码学中的一个重要组成部分，以其简洁的数学原理和直观的加密过程，为我们理解密码学的基本概念提供了宝贵的视角。它通过线性函数 E(x) = (ax + b) mod m 将明文转换为密文，并通过其逆函数 D(y) = a^-1(y - b) mod m 进行解密。其中，密钥 a 与字母表大小 m 互质是确保可逆性的关键条件。\n尽管仿射密码在现代密码学中因其极小的密钥空间和易受频率分析攻击的弱点而不再具备实际的安全性，但它在密码学教育、历史研究以及编程实践中仍然扮演着不可或缺的角色。通过学习和实现仿射密码，我们不仅能够掌握古典密码的基本原理，还能为理解更复杂的加密算法和现代密码学奠定坚实的基础。\n从凯撒密码到仿射密码，再到更复杂的加密技术，密码学的发展史是一部不断演进的攻防史。每一次加密技术的进步都伴随着破解技术的突破，反之亦然。仿射密码正是这一演进过程中的一个重要里程碑，它以其独特的数学美感和历史意义，继续在密码学领域中闪耀着光芒。\n","date":"2025-08-12T17:15:00+08:00","permalink":"http://localhost:1313/post/programmingtechnology/classicalcryptography/affinecipher/","title":"仿射密码"},{"content":"什么是凯撒密码？ 凯撒密码是一种替换密码（Substitution Cipher），也被称为移位密码（Shift Cipher）。它的加密过程非常简单：将明文中的每一个字母，用字母表上固定距离的另一个字母来替换。\n这个“固定的距离”就是加密的密钥（Key）。\n例如，如果我们选择的密钥是 3，那么：\n字母 A 会被替换成字母表中向后移动 3 位的 D。 字母 B 会被替换成 E。 \u0026hellip; 字母 X 会被替换成 A（因为 X -\u0026gt; Y -\u0026gt; Z -\u0026gt; A，字母表是循环的）。 字母 Y 会被替换成 B。 字母 Z 会被替换成 C。 这个过程就像是将整个字母表向左平移了 3 位，形成了一个新的对应关系。\n加密示例 (密钥 = 3):\n明文 (Plaintext): HELLO WORLD 密文 (Ciphertext): KHOOR ZRUOG 凯撒密码的数学表示 尽管凯撒密码很简单，但我们依然可以用数学语言来精确地描述它。我们将字母表中的每个字母映射为一个数字（例如，A=0, B=1, \u0026hellip;, Z=25）。\n设：\nP 为明文字母对应的数字。 C 为密文字母对应的数字。 k 为密钥（位移量）。 那么，加密过程可以表示为： $$ C = (P + k) \\pmod{26} $$\n解密过程则是加密的逆运算，即向前移动 k 位： $$ P = (C - k) \\pmod{26} $$\n这里的 mod 26 (模26) 运算是关键，它完美地实现了字母表的循环。例如，当加密 X (23) 且密钥为 3 时： C = (23 + 3) mod 26 = 26 mod 26 = 0，对应的字母是 A。\n当解密 A (0) 且密钥为 3 时： P = (0 - 3) mod 26 = -3 mod 26。在模运算中，-3 和 23 是同余的，所以结果是 23，对应的字母是 X。\n如何破解凯撒密码？ 凯撒密码的安全性极低，因为它存在致命的弱点。主要有两种破解方法：\n1. 暴力破解 (Brute-force Attack) 由于英文字母只有 26 个，所以可能的密钥也只有 25 种（密钥为 0 或 26 没有意义，因为明文和密文会一样）。攻击者可以简单地将所有可能的密钥（从 1 到 25）全部尝试一遍，直到解密出的文本有意义为止。这个过程对于计算机来说是瞬时完成的。\n2. 频率分析 (Frequency Analysis) 在任何一种自然语言中，不同字母的出现频率是有统计规律的。例如，在英语中，字母 E 的出现频率最高，其次是 T, A, O 等。\n攻击者可以统计密文中每个字母的出现频率，找到出现次数最多的那个密文字母。它有极大的概率对应明文中的 E。一旦确定了这一对映射关系（比如密文 H 对应明文 E），就可以立即推算出密钥 k（从 E 到 H 的位移是 3），从而破解整个密码。\nC++ 代码实现 下面是一个完整的 C++ 程序，它实现了凯撒密码的加密和解密功能。代码结构清晰，并包含了详细的注释。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cctype\u0026gt; std::string caesarEncrypt(const std::string\u0026amp; text, int shift); std::string caesarDecrypt(const std::string\u0026amp; text, int shift); int main() { std::string message; int shift; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 凯撒密码加密/解密程序\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;\\n请输入要处理的消息: \u0026#34;; std::getline(std::cin, message); std::cout \u0026lt;\u0026lt; \u0026#34;请输入移位量 (0-25 之间的整数): \u0026#34;; std::cin \u0026gt;\u0026gt; shift; shift = shift % 26; if (shift \u0026lt; 0) { shift += 26; } std::string encryptedMessage = caesarEncrypt(message, shift); std::cout \u0026lt;\u0026lt; \u0026#34;\\n加密后的密文是: \u0026#34; \u0026lt;\u0026lt; encryptedMessage \u0026lt;\u0026lt; std::endl; std::string decryptedMessage = caesarDecrypt(encryptedMessage, shift); std::cout \u0026lt;\u0026lt; \u0026#34;解密后的明文是: \u0026#34; \u0026lt;\u0026lt; decryptedMessage \u0026lt;\u0026lt; std::endl; return 0; } /** * @brief 对给定的文本进行凯撒加密 * @param text 要加密的明文 * @param shift 移位密钥 (0-25) * @return 加密后的密文 */ std::string caesarEncrypt(const std::string\u0026amp; text, int shift) { std::string result = \u0026#34;\u0026#34;; for (char c : text) { if (isalpha(c)) { char base = isupper(c) ? \u0026#39;A\u0026#39; : \u0026#39;a\u0026#39;; // Apply encryption formula: C = (P + k) % 26 result += static_cast\u0026lt;char\u0026gt;((c - base + shift) % 26 + base); } else { result += c; } } return result; } /** * @brief 对给定的文本进行凯撒解密 * @param text 要解密的密文 * @param shift 移位密钥 (0-25) * @return 解密后的明文 */ std::string caesarDecrypt(const std::string\u0026amp; text, int shift) { std::string result = \u0026#34;\u0026#34;; for (char c : text) { if (isalpha(c)) { char base = isupper(c) ? \u0026#39;A\u0026#39; : \u0026#39;a\u0026#39;; result += static_cast\u0026lt;char\u0026gt;((c - base - shift + 26) % 26 + base); } else { result += c; } } return result; } ","date":"2025-08-11T16:34:53+08:00","permalink":"http://localhost:1313/post/programmingtechnology/classicalcryptography/caesarcipher/","title":"凯撒密码"}]