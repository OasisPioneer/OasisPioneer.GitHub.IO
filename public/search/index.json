[{"content":"什么是波利比奥斯方阵密码？ 波利比奥斯方阵密码（Polybius Square Cipher），又称棋盘密码，是一种替换密码（Substitution Cipher），由古希腊历史学家波利比奥斯（Polybius）在公元前2世纪发明。它将字母映射到数字对，从而实现加密。这种密码最初是为了通过火炬信号进行远距离通信而设计的，每个字母通过其在方阵中的坐标来表示。\n波利比奥斯方阵通常是一个5x5的网格，包含了25个英文字母。由于英文字母有26个，通常会将字母 I 和 J 合并处理，或者将 K 替换为 C 等，以适应25个格子的限制。每个字母由其所在的行号和列号组成的数字对来表示。\n波利比奥斯方阵示例 (5x5):\n1 2 3 4 5 1 A B C D E 2 F G H I/J K 3 L M N O P 4 Q R S T U 5 V W X Y Z 加密过程：\n构建方阵： 确定一个5x5的方阵，将字母填入其中。通常 I 和 J 共用一个格子。 明文转换： 将明文中的每个字母替换为其在方阵中的坐标对。坐标通常是先行后列。 例如，如果明文是 HELLO：\nH 在第2行第3列，表示为 23。 E 在第1行第5列，表示为 15。 L 在第3行第1列，表示为 31。 L 在第3行第1列，表示为 31。 O 在第3行第4列，表示为 34。 加密示例:\n明文 (Plaintext): HELLO 密文 (Ciphertext): 2315313134 波利比奥斯方阵密码的数学表示 波利比奥斯方阵密码的数学表示相对简单，它主要涉及将字母映射到二维坐标，然后将这些坐标串联起来。虽然没有像凯撒密码或维吉尼亚密码那样直接的模运算公式，但其核心是基于查表和坐标转换。\n设：\n字母表 Σ = {A, B, ..., Z} 方阵 M 是一个 5x5 的矩阵，其中 M[row][col] 存储一个字母。 char_to_coords(c) 函数返回字母 c 在方阵 M 中的坐标 (row, col)。 coords_to_char(row, col) 函数返回坐标 (row, col) 在方阵 M 中对应的字母。 加密过程：\n对于明文中的每个字母 P_i：\n找到 P_i 在方阵 M 中的坐标 (row_i, col_i)。 将 row_i 和 col_i 转换为字符串形式，并连接起来形成密文的一部分。 解密过程：\n对于密文中的每对数字 (d1, d2)：\n将 d1 解释为行号 row，d2 解释为列号 col。 找到方阵 M 中 M[row][col] 对应的字母 P_i。 示例方阵 (5x5，I/J合并):\n1 2 3 4 5 1 A B C D E 2 F G H I/J K 3 L M N O P 4 Q R S T U 5 V W X Y Z 加密函数 (伪代码):\nfunction encrypt(plaintext): ciphertext = \u0026#34;\u0026#34; for each char P in plaintext: if P is an alphabet letter: if P == \u0026#39;J\u0026#39;: P = \u0026#39;I\u0026#39; // Handle I/J merge (row, col) = char_to_coords(P) ciphertext += to_string(row) + to_string(col) else: ciphertext += P // Non-alphabet characters remain unchanged return ciphertext 解密函数 (伪代码):\nfunction decrypt(ciphertext): plaintext = \u0026#34;\u0026#34; for i from 0 to length(ciphertext) - 1 step 2: d1 = to_int(ciphertext[i]) d2 = to_int(ciphertext[i+1]) P = coords_to_char(d1, d2) plaintext += P return plaintext 这种密码的数学表示更侧重于查找表和索引操作，而不是复杂的算术运算。\n如何破解波利比奥斯方阵密码？ 波利比奥斯方阵密码虽然将字母转换成了数字对，但它仍然是一种单表替换密码。这意味着每个明文字母总是被相同的数字对替换。因此，它和凯撒密码一样，容易受到频率分析的攻击。\n1. 频率分析 (Frequency Analysis) 这是破解波利比奥斯方阵密码最主要的方法。攻击者可以统计密文中每个数字对的出现频率，并将其与已知语言（例如英语）中字母的频率分布进行比较。例如，在英语中，字母 E 的出现频率最高，那么密文中出现频率最高的数字对很可能就代表 E。一旦确定了几个这样的对应关系，就可以逐步推断出整个方阵的映射关系，从而解密密文。\n破解步骤：\n统计密文频率： 将密文中的数字对（例如，23, 15 等）进行统计，找出出现频率最高的数字对。 匹配语言频率： 将这些高频数字对与目标语言（如英语）中高频字母（如 E, T, A, O, I, N 等）进行匹配。 重建方阵： 根据推断出的映射关系，逐步重建波利比奥斯方阵。 解密： 使用重建的方阵来解密整个密文。 2. 暴力破解 (Brute-force Attack) 虽然不如频率分析高效，但理论上也可以通过暴力破解来尝试所有可能的方阵排列。然而，由于方阵的排列组合数量巨大，这种方法在实践中是不可行的。\n3. 已知明文攻击 (Known-plaintext Attack) 如果攻击者拥有一些明文和对应的密文对，那么破解将变得非常容易。通过比较明文和密文，可以直接推导出方阵的映射关系。\n4. 字典攻击 (Dictionary Attack) 如果密文是短语或单词，攻击者可以尝试使用常见的单词或短语进行加密，然后与密文进行比较，以找到匹配项。\n总的来说，波利比奥斯方阵密码的安全性非常低，不适用于保护敏感信息。它主要作为密码学教学中的一个早期示例，展示了将字母转换为数字表示的初步尝试。\nC++ 代码实现 下面是一个简单的 C++ 程序，它实现了波利比奥斯方阵密码的加密和解密功能。代码结构清晰，并包含了详细的注释。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;map\u0026gt; // Define the Polybius Square (5x5, I/J combined) const char polybiusSquare[5][5] = { {\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;}, {\u0026#39;F\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;K\u0026#39;}, // I/J combined {\u0026#39;L\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;P\u0026#39;}, {\u0026#39;Q\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;U\u0026#39;}, {\u0026#39;V\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Z\u0026#39;} }; // Map to store character to coordinates for encryption std::map\u0026lt;char, std::pair\u0026lt;int, int\u0026gt;\u0026gt; charToCoords; // Function to initialize the charToCoords map void initializeMap() { for (int i = 0; i \u0026lt; 5; ++i) { for (int j = 0; j \u0026lt; 5; ++j) { charToCoords[polybiusSquare[i][j]] = {i + 1, j + 1}; // 1-indexed } } charToCoords[\u0026#34;J\u0026#34;] = charToCoords[\u0026#34;I\u0026#34;]; // Handle J as I } std::string polybiusEncrypt(const std::string\u0026amp; plaintext); std::string polybiusDecrypt(const std::string\u0026amp; ciphertext); int main() { initializeMap(); // Initialize the map once std::string message; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 波利比奥斯方阵密码加密/解密程序\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;\\n请输入要处理的消息 (只包含字母): \u0026#34;; std::getline(std::cin, message); std::string encryptedMessage = polybiusEncrypt(message); std::cout \u0026lt;\u0026lt; \u0026#34;\\n加密后的密文是: \u0026#34; \u0026lt;\u0026lt; encryptedMessage \u0026lt;\u0026lt; std::endl; std::string decryptedMessage = polybiusDecrypt(encryptedMessage); std::cout \u0026lt;\u0026lt; \u0026#34;解密后的明文是: \u0026#34; \u0026lt;\u0026lt; decryptedMessage \u0026lt;\u0026lt; std::endl; return 0; } /** * @brief 对给定的文本进行波利比奥斯方阵加密 * @param plaintext 要加密的明文 * @return 加密后的密文 (数字串) */ std::string polybiusEncrypt(const std::string\u0026amp; plaintext) { std::string ciphertext = \u0026#34;\u0026#34;; for (char pChar : plaintext) { pChar = toupper(pChar); // Convert to uppercase for consistency if (isalpha(pChar)) { if (pChar == \u0026#39;J\u0026#39;) pChar = \u0026#39;I\u0026#39;; // Handle J as I if (charToCoords.count(pChar)) { ciphertext += std::to_string(charToCoords[pChar].first); ciphertext += std::to_string(charToCoords[pChar].second); } } else { ciphertext += pChar; // Non-alphabet characters remain unchanged } } return ciphertext; } /** * @brief 对给定的密文进行波利比奥斯方阵解密 * @param ciphertext 要解密的密文 (数字串) * @return 解密后的明文 */ std::string polybiusDecrypt(const std::string\u0026amp; ciphertext) { std::string plaintext = \u0026#34;\u0026#34;; for (size_t i = 0; i \u0026lt; ciphertext.length(); i += 2) { if (isdigit(ciphertext[i]) \u0026amp;\u0026amp; isdigit(ciphertext[i+1])) { int row = ciphertext[i] - \u0026#39;0\u0026#39;; int col = ciphertext[i+1] - \u0026#39;0\u0026#39;; if (row \u0026gt;= 1 \u0026amp;\u0026amp; row \u0026lt;= 5 \u0026amp;\u0026amp; col \u0026gt;= 1 \u0026amp;\u0026amp; col \u0026lt;= 5) { plaintext += polybiusSquare[row - 1][col - 1]; // Convert back to 0-indexed } } else { // Handle non-digit characters (e.g., spaces) that were not encrypted plaintext += ciphertext[i]; if (i + 1 \u0026lt; ciphertext.length()) { plaintext += ciphertext[i+1]; } i -= 1; // Adjust index for single non-digit char or pair } } return plaintext; } ","date":"2025-08-14T17:34:00+08:00","permalink":"http://localhost:1313/post/programmingtechnology/classicalcryptography/polybius/","title":"波利比奥斯方阵密码"},{"content":"前言：为什么钱包选择至关重要？ 在 Web3 和加密货币的世界里，你的钱包就是你的银行账户、身份凭证和保险箱。与传统银行不同，这里没有客服电话可以帮你重置密码或追回被盗资金。你必须成为自己资产的唯一守护者。因此，选择一个安全可靠的钱包，是进入这个领域最重要的一步。\n钱包的核心：热钱包 vs. 冷钱包 在讨论具体类型之前，我们首先需要理解两个核心概念：热钱包和冷钱包。它们的根本区别在于私钥（访问你资产的唯一钥匙）是否接触互联网。\n热钱包 (Hot Wallet): 指的是私钥存储在联网设备上的钱包，如手机 App 或浏览器插件。\n优点: 使用方便，适合日常交易和与 DApp 交互。 缺点: 始终在线，容易成为黑客攻击的目标，安全性相对较低。 冷钱包 (Cold Wallet): 指的是私钥离线存储的钱包，只有在签名交易时才短暂连接设备。\n优点: 物理隔离，安全性极高，是存储大额或长期持有资产的最佳选择。 缺点: 操作相对繁琐，不适合高频交易。 主流钱包类型深度解析 了解了冷热之分后，我们再来看市面上主流的三种钱包形态。\n软件钱包 (Software Wallet) - 便捷的热钱包 软件钱包是最常见的钱包类型，通常以桌面应用、浏览器插件或手机 App 的形式存在。\n优点: 极致便捷: 安装即可使用，转账、收款、与 DApp 交互都非常流畅。 免费: 大部分软件钱包都是免费的。 功能丰富: 通常集成了 DApp 浏览器、行情查看、多链支持等功能。 缺点: 安全风险高: 由于设备始终联网，面临的攻击面最广。常见的风险包括： 木马病毒: 电脑或手机中毒，私钥或助记词被窃取。 钓鱼攻击: 访问了假的网站或 App，授权了恶意合约。 供应链攻击: 下载了被篡改的钱包应用。 适用场景: 存放少量资金，用于日常小额交易和探索 Web3 应用。 代表产品: MetaMask, Trust Wallet, Phantom 硬件钱包 (Hardware Wallet) - 最均衡的冷钱包 硬件钱包是一个专门设计用于存储私钥的物理设备，外形类似 U 盘。它通过将签名过程隔离在设备内部，实现了极高的安全性。\n优点: 安全性高: 私钥永不离开硬件设备，即使连接了中毒的电脑，资产依然安全。 物理确认: 所有交易都需要在设备上按下物理按键进行确认，有效防止远程攻击。 资产掌控感强: 让你真正拥有自己的私钥。 缺点: 需要购买: 价格从几百到上千元不等。 操作稍繁琐: 每次交易都需要连接设备并进行物理确认。 （极低概率）供应链风险: 理论上存在设备在生产或运输环节被植入后门的风险，因此务必从官方渠道购买。 适用场景: 存储大额资产，或作为长期投资的安全保障。 代表产品: Ledger, Trezor, OneKey 纸钱包 (Paper Wallet) - 极致安全的冷钱包 纸钱包本质上就是将你的公钥（地址）和私钥打印在一张纸上。这是一种最原始、最彻底的离线存储方式。\n优点: 安全性极高: 完全物理隔离，只要纸张本身安全，资产就绝对安全。 零成本: 你只需要一台安全的电脑和一台打印机。 缺点: 极其脆弱: 纸张容易因火灾、水浸、褪色等原因损毁，导致资产永久丢失。 操作极不方便: 使用时需要将私钥导入软件钱包，这会使其“变热”，通常是一次性使用。 易操作失误: 创建和使用过程对新手不友好，容易出错。 适用场景: 适合作为“传家宝”式的长期、深度存储，且使用者具备足够的安全知识。 总结与建议 钱包类型 安全性 便捷性 成本 核心风险 推荐用途 软件钱包 ★☆☆☆☆ ★★★★★ 免费 木马、钓鱼、网络攻击 小额、高频交易 硬件钱包 ★★★★☆ ★★★☆☆ 较高 物理丢失、供应链攻击 大额、长期存储 纸钱包 ★★★★★ ★☆☆☆☆ 极低 物理损坏、丢失 终极离线备份 给新手的建议：\n组合使用: 不要把所有鸡蛋放在一个篮子里。使用一个硬件钱包存储你的大部分资产，再用一个软件钱包存放少量资金用于日常交互。 助记词是生命: 无论使用哪种钱包，物理备份并妥善保管你的助记词（通常是12或24个单词）。不要截图、不要发邮件、不要存云盘！ 从官方渠道下载/购买: 永远只从官网或官方应用商店获取钱包应用和硬件设备。 希望这篇文章能帮助你迈出安全进入加密世界的第一步。\n","date":"2025-08-14T17:10:00+08:00","permalink":"http://localhost:1313/post/cryptocurrency/choosewallet/","title":"选择钱包"},{"content":"什么是一次性密码本？ 一次性密码本（One-Time Pad, OTP），又称“一次一密”，是古典密码学中一种理论上被证明绝对安全的加密算法。它由美国电话电报公司的吉尔伯特·维纳姆（Gilbert Vernam）于1917年发明，并由克劳德·香农（Claude Shannon）在信息论中证明了其不可破译性。\n一次性密码本的核心思想是使用一个与明文等长、完全随机且只使用一次的密钥。加密过程是将明文与密钥进行逐位（或逐字符）的异或（XOR）运算。由于密钥的随机性、等长性和一次性，即使攻击者截获了密文，也无法从中获取任何关于明文的信息。\n一次性密码本的三个核心条件：\n密钥必须是真正随机的： 密钥的生成必须是完全不可预测的，不能有任何模式或可重复性。 密钥必须与明文等长： 密钥的长度必须至少与要加密的明文长度相同。 密钥必须只使用一次： 每个密钥只能用于加密一条消息，之后必须立即销毁，不能重复使用。 如果这三个条件都得到满足，那么一次性密码本是唯一一种被数学证明为绝对安全的加密方案。任何密文都可能对应任何明文，因为存在一个密钥可以将密文转换为任何可能的明文，这使得攻击者无法区分真实的明文。\n加密示例 (以字母为例，A=0, B=1, \u0026hellip;, Z=25):\n假设明文为 HELLO，密钥为 XMCKL。\n明文 (P) H (7) E (4) L (11) L (11) O (14) 密钥 (K) X (23) M (12) C (2) K (10) L (11) 加密 (P+K mod 26) (7+23)%26=4 (E) (4+12)%26=16 (Q) (11+2)%26=13 (N) (11+10)%26=21 (V) (14+11)%26=25 (Z) 密文 (C) E Q N V Z 明文 (Plaintext): HELLO 密钥 (Key): XMCKL 密文 (Ciphertext): EQNVZ 一次性密码本的数学表示 一次性密码本的数学表示通常使用异或（XOR）运算，尤其是在二进制层面。如果我们将明文和密钥都视为二进制序列，那么加密和解密过程可以表示为：\n设：\nP 为明文（二进制序列）。 K 为密钥（二进制序列）。 C 为密文（二进制序列）。 那么，加密过程可以表示为： $$ C = P \\oplus K $$\n解密过程则是： $$ P = C \\oplus K $$\n其中 $\\oplus$ 表示异或运算。异或运算的特性是 A \\oplus B \\oplus B = A，这使得加密和解密可以使用相同的操作。当明文和密钥都是字母时，我们可以将它们转换为数字（例如，A=0, B=1, \u0026hellip;, Z=25），然后进行模加运算，这与异或运算在概念上是相似的。\n设：\nP_i 为明文的第 i 个字母对应的数字。 K_i 为密钥的第 i 个字母对应的数字。 C_i 为密文的第 i 个字母对应的数字。 那么，加密过程可以表示为： $$ C_i = (P_i + K_i) \\pmod{26} $$\n解密过程则是： $$ P_i = (C_i - K_i + 26) \\pmod{26} $$\n这里的 mod 26 (模26) 运算确保了结果在 0 到 25 之间，并且处理了负数的情况。\n一次性密码本为何不可破译？ 一次性密码本之所以被认为是理论上绝对安全的，其核心在于满足了香农的**完美保密性（Perfect Secrecy）**定义。完美保密性意味着，给定密文，攻击者无法获得任何关于明文的信息，即密文不泄露任何明文信息。\n具体来说，一次性密码本的不可破译性基于以下几点：\n密钥的完全随机性： 密钥是真正随机生成的，这意味着密钥中的每一个位（或字符）都是独立且均匀分布的。攻击者无法通过任何统计方法或模式分析来预测密钥的下一个部分。\n密钥与明文等长： 密钥的长度与明文完全相同。这保证了密钥的每一个部分都只用于加密明文的对应部分，没有重复使用。\n密钥的一次性使用： 密钥只使用一次。这是最关键的条件。如果密钥被重复使用，即使是随机生成的，也会引入可分析的模式，从而导致密码被破解（例如，通过异或两个使用相同密钥加密的密文，可以得到两个明文的异或结果，从而进行频率分析）。\n密文的均匀分布： 当密钥是完全随机且与明文等长时，生成的密文也是完全随机且均匀分布的。这意味着，对于任何给定的密文，所有可能的明文都以相同的概率对应这个密文。攻击者无法通过分析密文的统计特性来推断出原始明文的任何信息。\n举例来说，如果密文是 X，攻击者不知道明文是 A 还是 B。如果明文是 A，那么密钥必须是 K_A 才能生成 X；如果明文是 B，那么密钥必须是 K_B 才能生成 X。由于密钥是完全随机的，K_A 和 K_B 都是同样可能的密钥。因此，攻击者无法区分明文是 A 还是 B，因为两种情况都同样符合逻辑。\n正是由于这些严格的条件，一次性密码本在理论上提供了无条件的安全。然而，在实际应用中，生成、分发和管理真正随机且只使用一次的等长密钥是非常困难和昂贵的，这限制了其大规模应用。它主要用于高度机密的通信，例如外交和军事领域。\nC++ 代码实现 下面是一个简单的 C++ 程序，它演示了一次性密码本的加密和解密功能。请注意，在实际应用中，密钥的生成和管理会更加复杂，以确保其真正的随机性和一次性。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;random\u0026gt; #include \u0026lt;chrono\u0026gt; // Function to generate a random key of a given length std::string generateRandomKey(int length) { std::string key = \u0026#34;\u0026#34;; // Use a random device to seed the random number generator std::random_device rd; // Use the Mersenne Twister engine std::mt19937 gen(rd()); // Define a distribution for characters (e.g., \u0026#39;A\u0026#39; to \u0026#39;Z\u0026#39;) std::uniform_int_distribution\u0026lt;\u0026gt; distrib(0, 25); // 0-25 for A-Z for (int i = 0; i \u0026lt; length; ++i) { key += static_cast\u0026lt;char\u0026gt;(\u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;[distrib(gen)]); } return key; } // Function to convert a character to its 0-25 integer equivalent int charToInt(char c) { if (isupper(c)) { return c - \u0026#39;A\u0026#39;; } else if (islower(c)) { return c - \u0026#39;a\u0026#39;; } return -1; // Not an alphabet character } // Function to convert an integer (0-25) back to a character char intToChar(int i, char originalCase) { if (isupper(originalCase)) { return static_cast\u0026lt;char\u0026gt;(\u0026#39;A\u0026#39; + i); } else { return static_cast\u0026lt;char\u0026gt;(\u0026#39;a\u0026#39; + i); } } std::string oneTimePadEncrypt(const std::string\u0026amp; plaintext, const std::string\u0026amp; key); std::string oneTimePadDecrypt(const std::string\u0026amp; ciphertext, const std::string\u0026amp; key); int main() { std::string message; std::string key; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 一次性密码本加密/解密程序\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;\\n请输入要处理的消息 (只包含字母): \u0026#34;; std::getline(std::cin, message); // Generate a random key of the same length as the message key = generateRandomKey(message.length()); std::cout \u0026lt;\u0026lt; \u0026#34;生成的密钥是: \u0026#34; \u0026lt;\u0026lt; key \u0026lt;\u0026lt; std::endl; std::string encryptedMessage = oneTimePadEncrypt(message, key); std::cout \u0026lt;\u0026lt; \u0026#34;\\n加密后的密文是: \u0026#34; \u0026lt;\u0026lt; encryptedMessage \u0026lt;\u0026lt; std::endl; std::string decryptedMessage = oneTimePadDecrypt(encryptedMessage, key); std::cout \u0026lt;\u0026lt; \u0026#34;解密后的明文是: \u0026#34; \u0026lt;\u0026lt; decryptedMessage \u0026lt;\u0026lt; std::endl; return 0; } /** * @brief 对给定的文本进行一次性密码本加密 * @param plaintext 要加密的明文 * @param key 密钥 (与明文等长，完全随机) * @return 加密后的密文 */ std::string oneTimePadEncrypt(const std::string\u0026amp; plaintext, const std::string\u0026amp; key) { std::string ciphertext = \u0026#34;\u0026#34;; for (size_t i = 0; i \u0026lt; plaintext.length(); ++i) { if (isalpha(plaintext[i])) { int pVal = charToInt(plaintext[i]); int kVal = charToInt(key[i]); int cVal = (pVal + kVal) % 26; ciphertext += intToChar(cVal, plaintext[i]); } else { ciphertext += plaintext[i]; } } return ciphertext; } /** * @brief 对给定的文本进行一次性密码本解密 * @param ciphertext 要解密的密文 * @param key 密钥 (与密文等长，完全随机) * @return 解密后的明文 */ std::string oneTimePadDecrypt(const std::string\u0026amp; ciphertext, const std::string\u0026amp; key) { std::string plaintext = \u0026#34;\u0026#34;; for (size_t i = 0; i \u0026lt; ciphertext.length(); ++i) { if (isalpha(ciphertext[i])) { int cVal = charToInt(ciphertext[i]); int kVal = charToInt(key[i]); int pVal = (cVal - kVal + 26) % 26; // Add 26 to handle negative results of modulo plaintext += intToChar(pVal, ciphertext[i]); } else { plaintext += ciphertext[i]; } } return plaintext; } ","date":"2025-08-13T23:41:29+08:00","permalink":"http://localhost:1313/post/programmingtechnology/classicalcryptography/one-timepad/","title":"一次性密码本"},{"content":"什么是维吉尼亚密码？ 维吉尼亚密码（Vigenère cipher）是一种多表替换密码（Polyalphabetic Substitution Cipher），它使用一系列凯撒密码组成密码字母表。与凯撒密码（单表替换密码）不同，维吉尼亚密码的加密不再是简单的固定移位，而是根据一个**密钥（Keyword）**的字母来决定每个明文字母的移位量。\n维吉尼亚密码在16世纪由意大利外交官吉奥万·巴蒂斯塔·贝拉索（Giovan Battista Bellaso）发明，但后来被误认为是法国密码学家布莱斯·德·维吉尼亚（Blaise de Vigenère）的发明，因此得名。它在密码学史上具有重要地位，因为它在很长一段时间内被认为是不可破解的，被称为“不可破译的密码”（le chiffre indéchiffrable）。\n工作原理：\n维吉尼亚密码的核心思想是使用一个密钥单词。密钥单词的每个字母决定了明文对应位置字母的移位量。当密钥单词的长度不足以覆盖整个明文时，密钥会重复使用。\n例如，如果密钥是 KEY，明文是 ATTACKATDAWN：\n重复密钥： 将密钥重复，使其长度与明文相同。 明文: ATTACKATDAWN 密钥: KEYKEYKEYKEY\n逐字母加密： 每个明文字母根据其对应密钥字母的移位量进行凯撒加密。\n明文 A (0) 对应密钥 K (10)。 A 移位 10 位变成 K。 明文 T (19) 对应密钥 E (4)。 T 移位 4 位变成 X。 明文 T (19) 对应密钥 Y (24)。 T 移位 24 位变成 R。 以此类推。 加密示例:\n明文 (Plaintext): ATTACKATDAWN 密钥 (Key): LEMON 重复密钥: LEMONLEMONLE 密文 (Ciphertext): LXFOPVEFRNHR 维吉尼亚密码的数学表示 维吉尼亚密码的加密和解密可以利用模运算来表示。我们将字母表中的每个字母映射为一个数字（例如，A=0, B=1, \u0026hellip;, Z=25）。\n设：\nP_i 为明文的第 i 个字母对应的数字。 C_i 为密文的第 i 个字母对应的数字。 K_i 为密钥的第 i 个字母对应的数字（密钥循环使用）。 那么，加密过程可以表示为： $$ C_i = (P_i + K_i) \\pmod{26} $$\n解密过程则是加密的逆运算： $$ P_i = (C_i - K_i + 26) \\pmod{26} $$\n这里的 mod 26 (模26) 运算确保了结果在 0 到 25 之间，并且处理了负数的情况。例如，当明文 A (0) 遇到密钥 L (11) 时： C = (0 + 11) mod 26 = 11，对应的字母是 L。\n当明文 T (19) 遇到密钥 E (4) 时： C = (19 + 4) mod 26 = 23，对应的字母是 X。\n如何破解维吉尼亚密码？ 尽管维吉尼亚密码在很长一段时间内被认为是不可破解的，但它并非绝对安全。相比于凯撒密码和阿特巴希密码，维吉尼亚密码的破解难度大大增加，因为它引入了多表替换，使得简单的频率分析不再有效。然而，如果攻击者能够确定密钥的长度，那么维吉尼亚密码就可以被分解成多个凯撒密码进行破解。\n1. 确定密钥长度 这是破解维吉尼亚密码最关键的一步。一旦密钥长度 L 被确定，密文就可以被分成 L 个子密文，每个子密文都是由一个凯撒密码加密的。常用的确定密钥长度的方法有：\na. 卡西斯基考试法 (Kasiski Examination) 卡西斯基考试法通过寻找密文中重复出现的字母序列来推测密钥长度。如果一个重复的字母序列在明文中出现，并且它们之间的距离是密钥长度的整数倍，那么在密文中它们也会以相同的形式重复出现。通过计算这些重复序列之间距离的最大公约数（GCD），可以得到密钥长度的可能值。\n例如，如果密文中“ABC”重复出现，第一次在位置5，第二次在位置15，那么它们之间的距离是10。如果“XYZ”重复出现，第一次在位置8，第二次在位置28，距离是20。那么密钥长度可能是10和20的公约数，即10或5或2或1。\nb. 重合指数法 (Index of Coincidence, IC) 重合指数是衡量一段文本中任意两个随机选择的字母相同的概率。对于英文文本，其重合指数约为0.067。对于随机文本或均匀分布的文本，其重合指数约为0.038。\n维吉尼亚密码的破解可以利用重合指数。攻击者可以尝试不同的密钥长度 L，将密文分成 L 个子密文。如果假设的密钥长度是正确的，那么每个子密文都将是一个凯撒密码加密的文本，其重合指数应该接近英文的0.067。通过计算不同假设密钥长度下的子密文的重合指数，最接近0.067的那个长度很可能就是真实的密钥长度。\n2. 频率分析破解子密文 一旦密钥长度 L 被确定，密文就被分解成了 L 个独立的凯撒密码。每个子密文都可以使用频率分析法（与破解凯撒密码相同的方法）来单独破解。通过分析每个子密文的字母频率分布，并与英文的字母频率分布进行比较，可以确定每个子密文的移位量，从而推导出密钥的每个字母。\n3. 组合密钥并解密 当所有子密文的移位量都被确定后，就可以组合这些移位量来得到完整的密钥。然后，使用这个密钥对原始密文进行解密，即可恢复明文。\n尽管维吉尼亚密码比凯撒密码更复杂，但它仍然是古典密码学的一部分，在现代密码学中已经不再安全。现代密码学使用更复杂的算法和更长的密钥来确保信息的安全性。\nC++ 代码实现 下面是一个完整的 C++ 程序，它实现了维吉尼亚密码的加密和解密功能。代码结构清晰，并包含了详细的注释。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cctype\u0026gt; // Function to convert a character to its 0-25 integer equivalent int charToInt(char c) { if (isupper(c)) { return c - \u0026#39;A\u0026#39;; } else if (islower(c)) { return c - \u0026#39;a\u0026#39;; } return -1; // Not an alphabet character } // Function to convert an integer (0-25) back to a character char intToChar(int i, char originalCase) { if (isupper(originalCase)) { return static_cast\u0026lt;char\u0026gt;(\u0026#39;A\u0026#39; + i); } else { return static_cast\u0026lt;char\u0026gt;(\u0026#39;a\u0026#39; + i); } } std::string vigenereEncrypt(const std::string\u0026amp; plaintext, const std::string\u0026amp; key); std::string vigenereDecrypt(const std::string\u0026amp; ciphertext, const std::string\u0026amp; key); int main() { std::string message; std::string key; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 维吉尼亚密码加密/解密程序\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;\\n请输入要处理的消息: \u0026#34;; std::getline(std::cin, message); std::cout \u0026lt;\u0026lt; \u0026#34;请输入密钥 (只包含字母): \u0026#34;; std::getline(std::cin, key); // Convert key to uppercase for consistent processing for (char \u0026amp;c : key) { c = toupper(c); } std::string encryptedMessage = vigenereEncrypt(message, key); std::cout \u0026lt;\u0026lt; \u0026#34;\\n加密后的密文是: \u0026#34; \u0026lt;\u0026lt; encryptedMessage \u0026lt;\u0026lt; std::endl; std::string decryptedMessage = vigenereDecrypt(encryptedMessage, key); std::cout \u0026lt;\u0026lt; \u0026#34;解密后的明文是: \u0026#34; \u0026lt;\u0026lt; decryptedMessage \u0026lt;\u0026lt; std::endl; return 0; } /** * @brief 对给定的文本进行维吉尼亚加密 * @param plaintext 要加密的明文 * @param key 密钥 * @return 加密后的密文 */ std::string vigenereEncrypt(const std::string\u0026amp; plaintext, const std::string\u0026amp; key) { std::string ciphertext = \u0026#34;\u0026#34;; int keyIndex = 0; for (char pChar : plaintext) { if (isalpha(pChar)) { int pVal = charToInt(pChar); int kVal = charToInt(key[keyIndex % key.length()]); int cVal = (pVal + kVal) % 26; ciphertext += intToChar(cVal, pChar); keyIndex++; } else { ciphertext += pChar; } } return ciphertext; } /** * @brief 对给定的文本进行维吉尼亚解密 * @param ciphertext 要解密的密文 * @param key 密钥 * @return 解密后的明文 */ std::string vigenereDecrypt(const std::string\u0026amp; ciphertext, const std::string\u0026amp; key) { std::string plaintext = \u0026#34;\u0026#34;; int keyIndex = 0; for (char cChar : ciphertext) { if (isalpha(cChar)) { int cVal = charToInt(cChar); int kVal = charToInt(key[keyIndex % key.length()]); int pVal = (cVal - kVal + 26) % 26; // Add 26 to handle negative results of modulo plaintext += intToChar(pVal, cChar); keyIndex++; } else { plaintext += cChar; } } return plaintext; } ","date":"2025-08-13T23:36:51+08:00","permalink":"http://localhost:1313/post/programmingtechnology/classicalcryptography/vigenerecipher/","title":"维吉尼亚密码"},{"content":"什么是ROT13密码？ ROT13（“rotate by 13 places”的缩写，意为“循环左移13位”）是一种替换密码（Substitution Cipher），它是凯撒密码的一种特殊形式。它的加密过程非常简单：将明文中的每一个字母，用字母表上向后移动13位的另一个字母来替换。\n由于英文字母表共有26个字母，而13正好是26的一半，这意味着对一个字母进行两次ROT13加密，就会回到原始字母。因此，ROT13既可以用于加密，也可以用于解密。\n例如，如果我们选择的移位量是 13，那么：\n字母 A 会被替换成字母表中向后移动 13 位的 N。 字母 B 会被替换成 O。 \u0026hellip; 字母 M 会被替换成 Z。 字母 N 会被替换成 A。 \u0026hellip; 字母 Z 会被替换成 M。 这个过程就像是将整个字母表向左平移了 13 位，形成了一个新的对应关系。\n加密示例:\n明文 (Plaintext): HELLO WORLD 密文 (Ciphertext): URYYB JBEYQ ROT13密码的数学表示 ROT13密码的数学表示与凯撒密码类似。我们将字母表中的每个字母映射为一个数字（例如，A=0, B=1, \u0026hellip;, Z=25）。\n设：\nP 为明文字母对应的数字。 C 为密文字母对应的数字。 k 为移位量，对于ROT13，k 固定为 13。 那么，加密过程可以表示为： $$ C = (P + 13) \\pmod{26} $$\n解密过程与加密过程相同，因为 (X + 13 + 13) mod 26 = (X + 26) mod 26 = X mod 26： $$ P = (C + 13) \\pmod{26} $$\n这里的 mod 26 (模26) 运算是关键，它完美地实现了字母表的循环。例如，当加密 A (0) 时： C = (0 + 13) mod 26 = 13 mod 26 = 13，对应的字母是 N。\n当加密 N (13) 时： C = (13 + 13) mod 26 = 26 mod 26 = 0，对应的字母是 A。\n如何“破解”ROT13密码？ ROT13密码的安全性极低，因为它本质上就是一种固定密钥的凯撒密码。它的“破解”方法非常简单，甚至可以说不需要破解，只需要再次应用ROT13算法即可。\n1. 再次应用ROT13算法 由于ROT13的移位量是13，而英文字母表有26个字母，13正好是26的一半。这意味着对一个字母进行两次ROT13加密操作，就会回到原始字母。例如，A 经过ROT13变成 N，N 再次经过ROT13又变回 A。因此，加密和解密使用相同的算法。\n这意味着，任何知道ROT13算法的人，都可以轻易地将ROT13加密的文本解密出来。它通常不用于保护敏感信息，而是用于隐藏一些剧透、谜题答案或不雅内容，以避免无意中看到。\n2. 频率分析 (Frequency Analysis) 虽然可以直接解密，但频率分析仍然可以用于识别文本是否经过ROT13加密。如果密文的字母频率分布与原始语言的频率分布呈现出13位的偏移，那么很可能就是ROT13加密。例如，如果密文中出现频率最高的字母是 N，而明文中最常见的字母是 E，那么 N 到 E 的偏移量正好是13（反向），这可以作为ROT13的证据。\nC++ 代码实现 下面是一个完整的 C++ 程序，它实现了ROT13密码的加密和解密功能。代码结构清晰，并包含了详细的注释。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cctype\u0026gt; std::string rot13Cipher(const std::string\u0026amp; text); int main() { std::string message; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; ROT13密码加密/解密程序\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;\\n请输入要处理的消息: \u0026#34;; std::getline(std::cin, message); std::string processedMessage = rot13Cipher(message); std::cout \u0026lt;\u0026lt; \u0026#34;\\n处理后的消息是: \u0026#34; \u0026lt;\u0026lt; processedMessage \u0026lt;\u0026lt; std::endl; return 0; } /** * @brief 对给定的文本进行ROT13加密或解密 * @param text 要处理的文本 * @return 处理后的文本 */ std::string rot13Cipher(const std::string\u0026amp; text) { std::string result = \u0026#34;\u0026#34;; for (char c : text) { if (isalpha(c)) { char base = isupper(c) ? \u0026#39;A\u0026#39; : \u0026#39;a\u0026#39;; // Apply ROT13 formula: (P + 13) % 26 result += static_cast\u0026lt;char\u0026gt;(base + (c - base + 13) % 26); } else { result += c; } } return result; } ","date":"2025-08-13T23:28:33+08:00","permalink":"http://localhost:1313/post/programmingtechnology/classicalcryptography/rot13cipher/","title":"ROT13密码"},{"content":"什么是阿特巴希密码？ 阿特巴希密码（Atbash Cipher）是一种替换密码（Substitution Cipher），也是已知最早的密码系统之一。它的加密原理非常简单：将字母表中的第一个字母替换为最后一个字母，第二个字母替换为倒数第二个字母，以此类推，形成一种反向的映射关系。\n例如，在拉丁字母表中：\n字母 A 会被替换成 Z。 字母 B 会被替换成 Y。 \u0026hellip; 字母 M 会被替换成 N。 字母 N 会被替换成 M。 \u0026hellip; 字母 Z 会被替换成 A。 这种替换是固定的，不需要密钥，因为其替换规则本身就是固定的“密钥”。\n加密示例:\n明文 (Plaintext): HELLO WORLD 密文 (Ciphertext): SVOOL DLIOW 阿特巴希密码的数学表示 阿特巴希密码的数学表示也相对简单。我们将字母表中的每个字母映射为一个数字（例如，A=0, B=1, \u0026hellip;, Z=25）。\n设：\nP 为明文字母对应的数字。 C 为密文字母对应的数字。 那么，加密过程可以表示为： $$ C = (25 - P) \\pmod{26} $$\n解密过程与加密过程相同，因为阿特巴希密码是对称的： $$ P = (25 - C) \\pmod{26} $$\n这里的 mod 26 (模26) 运算确保了结果在 0 到 25 之间。例如，当加密 A (0) 时： C = (25 - 0) mod 26 = 25 mod 26 = 25，对应的字母是 Z。\n当加密 Z (25) 时： C = (25 - 25) mod 26 = 0 mod 26 = 0，对应的字母是 A。\n如何破解阿特巴希密码？ 阿特巴希密码的安全性极低，甚至比凯撒密码还要低。因为它没有密钥，加密规则是固定的，所以一旦知道是阿特巴希密码，就可以直接解密。\n1. 直接解密 由于阿特巴希密码的加密和解密规则是相同的，且是公开的（A对Z，B对Y等），因此不需要任何密钥。攻击者一旦识别出这是阿特巴希密码，就可以直接应用其反向映射规则进行解密。\n2. 频率分析 (Frequency Analysis) 尽管可以直接解密，但频率分析仍然可以用于确认是否为阿特巴希密码。在任何一种自然语言中，不同字母的出现频率是有统计规律的。通过分析密文中字母的频率分布，并将其与已知语言的字母频率分布进行比较，可以推断出密文是否由阿特巴希密码加密。例如，如果密文中出现频率最高的字母对应到明文中的字母E（英语中最常见的字母），则可以进一步确认。\nC++ 代码实现 下面是一个完整的 C++ 程序，它实现了阿特巴希密码的加密和解密功能。代码结构清晰，并包含了详细的注释。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cctype\u0026gt; std::string atbashCipher(const std::string\u0026amp; text); int main() { std::string message; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 阿特巴希密码加密/解密程序\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;\\n请输入要处理的消息: \u0026#34;; std::getline(std::cin, message); std::string processedMessage = atbashCipher(message); std::cout \u0026lt;\u0026lt; \u0026#34;\\n处理后的消息是: \u0026#34; \u0026lt;\u0026lt; processedMessage \u0026lt;\u0026lt; std::endl; return 0; } /** * @brief 对给定的文本进行阿特巴希加密或解密 * @param text 要处理的文本 * @return 处理后的文本 */ std::string atbashCipher(const std::string\u0026amp; text) { std::string result = \u0026#34;\u0026#34;; for (char c : text) { if (isalpha(c)) { char base = isupper(c) ? \u0026#39;A\u0026#39; : \u0026#39;a\u0026#39;; // Apply Atbash formula: C = (25 - P) or P = (25 - C) result += static_cast\u0026lt;char\u0026gt;(base + (25 - (c - base))); } else { result += c; } } return result; } ","date":"2025-08-13T23:13:40+08:00","permalink":"http://localhost:1313/post/programmingtechnology/classicalcryptography/atbashcipher/","title":"阿特巴希密码"},{"content":"什么是仿射密码？ 仿射密码是一种替换密码（Substitution Cipher），它是凯撒密码的扩展，引入了更为复杂的数学运算。与凯撒密码仅仅通过加法进行位移不同，仿射密码结合了乘法和加法的线性变换。其核心在于将字母表中的每个字母映射到一个数值（通常A=0，B=1，\u0026hellip;，Z=25），然后通过一个仿射函数进行变换，最后再将变换后的数值映射回字母。\n仿射密码的数学表示 仿射密码的加密和解密过程都可以用数学语言精确地描述。我们将字母表中的每个字母映射为一个数字（例如，A=0, B=1, \u0026hellip;, Z=25）。\n加密函数 仿射密码的加密函数定义为：\n$$E(x) = (ax + b) \\pmod{m}$$\n其中：\nx 代表明文字母对应的数值（0到 m-1）。 a 和 b 是密钥，其中 a 必须与 m 互质（即它们的最大公约数为1）。 m 是字母表中的字母数量，对于英文字母表，m 通常取26。 E(x) 代表密文字母对应的数值。 互质条件的重要性： a 与 m 互质是仿射密码能够成功解密的必要条件。如果 a 和 m 不互质，那么在加密过程中可能会出现不同的明文字母加密后得到相同的密文字母的情况，导致解密时无法唯一确定原始明文，从而无法正确解密。\n解密函数 解密是加密的逆过程。为了从密文 y 恢复明文 x，我们需要找到加密函数 E(x) = (ax + b) mod m 的逆函数。从加密函数可以推导出：\n$$y \\equiv ax + b \\pmod{m}$$ $$y - b \\equiv ax \\pmod{m}$$\n为了解出 x，我们需要找到 a 在模 m 意义下的乘法逆元 a^-1，即满足 (a * a^-1) mod m = 1 的 a^-1。只有当 a 与 m 互质时，a^-1 才存在。\n解密函数定义为：\n$$D(y) = a^{-1}(y - b) \\pmod{m}$$\n其中：\ny 代表密文字母对应的数值。 a^-1 是 a 在模 m 意义下的乘法逆元。 b 是加密时使用的密钥 b。 D(y) 代表解密后明文字母对应的数值。 寻找乘法逆元： 乘法逆元 a^-1 可以通过扩展欧几里得算法或穷举法（对于较小的 m 值，如26）来找到。例如，当 m=26 时，与26互质的 a 值有1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25。每个 a 值都有其对应的唯一乘法逆元。\n示例 假设我们使用英文字母表（m=26），密钥 a=5，b=8。由于5和26互质，这是一个有效的密钥对。\n加密“HELLO”：\n将明文字母转换为数值： H -\u0026gt; 7 E -\u0026gt; 4 L -\u0026gt; 11 L -\u0026gt; 11 O -\u0026gt; 14\n应用加密函数 E(x) = (5x + 8) mod 26： H: E(7) = (57 + 8) mod 26 = (35 + 8) mod 26 = 43 mod 26 = 17 -\u0026gt; R E: E(4) = (54 + 8) mod 26 = (20 + 8) mod 26 = 28 mod 26 = 2 -\u0026gt; C L: E(11) = (511 + 8) mod 26 = (55 + 8) mod 26 = 63 mod 26 = 11 -\u0026gt; L L: E(11) = (511 + 8) mod 26 = (55 + 8) mod 26 = 63 mod 26 = 11 -\u0026gt; L O: E(14) = (5*14 + 8) mod 26 = (70 + 8) mod 26 = 78 mod 26 = 0 -\u0026gt; A\n加密后的密文是 RCLLA。\n解密“RCLLA”：\n首先找到 a=5 在模26下的乘法逆元 a^-1。我们需要找到一个数 x 使得 5x mod 26 = 1。通过计算可知 5 * 21 = 105，105 mod 26 = 1，所以 a^-1 = 21。\n将密文字母转换为数值： R -\u0026gt; 17 C -\u0026gt; 2 L -\u0026gt; 11 L -\u0026gt; 11 A -\u0026gt; 0\n应用解密函数 D(y) = 21(y - 8) mod 26： R: D(17) = 21(17 - 8) mod 26 = 21 * 9 mod 26 = 189 mod 26 = 7 -\u0026gt; H C: D(2) = 21(2 - 8) mod 26 = 21 * (-6) mod 26 = -126 mod 26 = 10 * 26 - 126 mod 26 = 4 -\u0026gt; E L: D(11) = 21(11 - 8) mod 26 = 21 * 3 mod 26 = 63 mod 26 = 11 -\u0026gt; L L: D(11) = 21(11 - 8) mod 26 = 21 * 3 mod 26 = 63 mod 26 = 11 -\u0026gt; L A: D(0) = 21(0 - 8) mod 26 = 21 * (-8) mod 26 = -168 mod 26 = 10 * 26 - 168 mod 26 = 260 - 168 mod 26 = 92 mod 26 = 14 -\u0026gt; O\n解密后的明文是 HELLO。\nC++ 代码实现 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;numeric\u0026gt; int modInverse(int a, int m) { a = a % m; for (int x = 1; x \u0026lt; m; x++) { if ((a * x) % m == 1) { return x; } } return -1; } bool isCoprime(int a) { return std::gcd(a, 26) == 1; } std::string encryptAffine(const std::string\u0026amp; text, int a, int b) { std::string result = \u0026#34;\u0026#34;; for (char c : text) { if (isalpha(c)) { char base = islower(c) ? \u0026#39;a\u0026#39; : \u0026#39;A\u0026#39;; int x = c - base; result += static_cast\u0026lt;char\u0026gt;(((a * x + b) % 26) + base); } else { result += c; } } return result; } std::string decryptAffine(const std::string\u0026amp; text, int a, int b) { std::string result = \u0026#34;\u0026#34;; int a_inv = modInverse(a, 26); if (a_inv == -1) { // This case should ideally be handled before calling decrypt return \u0026#34;Error: Modular inverse does not exist. \u0026#39;a\u0026#39; must be coprime to 26.\u0026#34;; } for (char c : text) { if (isalpha(c)) { char base = islower(c) ? \u0026#39;a\u0026#39; : \u0026#39;A\u0026#39;; int y = c - base; // (y - b) might be negative, add 26 to make it positive before modulo result += static_cast\u0026lt;char\u0026gt;(((a_inv * (y - b + 26)) % 26) + base); } else { result += c; } } return result; } int main() { std::string text; int a, b; std::cout \u0026lt;\u0026lt; \u0026#34;请输入要加密的文本: \u0026#34;; std::getline(std::cin, text); std::cout \u0026lt;\u0026lt; \u0026#34;请输入参数 a (必须与 26 互质，例如 1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25): \u0026#34;; std::cin \u0026gt;\u0026gt; a; // Validate \u0026#39;a\u0026#39; while (!isCoprime(a % 26)) { std::cout \u0026lt;\u0026lt; \u0026#34;参数 a 必须与 26 互质。请重新输入: \u0026#34;; std::cin \u0026gt;\u0026gt; a; } a = a % 26; std::cout \u0026lt;\u0026lt; \u0026#34;请输入参数 b (0-25): \u0026#34;; std::cin \u0026gt;\u0026gt; b; b = b % 26; std::string encrypted_text = encryptAffine(text, a, b); std::cout \u0026lt;\u0026lt; \u0026#34;加密后的文本: \u0026#34; \u0026lt;\u0026lt; encrypted_text \u0026lt;\u0026lt; std::endl; std::string decrypted_text = decryptAffine(encrypted_text, a, b); std::cout \u0026lt;\u0026lt; \u0026#34;解密后的文本: \u0026#34; \u0026lt;\u0026lt; decrypted_text \u0026lt;\u0026lt; std::endl; return 0; } 如何破解仿射密码？ 仿射密码的安全性非常低，因为它存在致命的弱点。主要有两种破解方法：\n1. 暴力破解 (Brute-force Attack) 仿射密码的密钥由两个部分组成：a 和 b。对于26个英文字母的字母表（m=26），a 必须与26互质。与26互质的数有12个（1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25）。b 可以是0到25之间的任意整数，有26种可能。因此，仿射密码的总密钥空间大小为 12 * 26 = 312。相较于现代密码学中动辄上百位的密钥长度，312种密钥组合是一个非常小的数字，这使得仿射密码极易受到暴力破解攻击。\n攻击者可以简单地将所有可能的密钥组合全部尝试一遍，直到解密出的文本有意义为止。这个过程对于计算机来说是瞬时完成的。\n2. 频率分析 (Frequency Analysis) 仿射密码属于单表替换密码的范畴，这意味着明文中的每一个特定字母，在加密过程中都会被唯一地替换为密文中的一个特定字母。在任何一种自然语言中，不同字母的出现频率是有统计规律的。例如，在英语中，字母 E 的出现频率最高，其次是 T, A, O 等。\n攻击者可以统计密文中每个字母的出现频率，找到出现次数最多的那个密文字母。它有极大的概率对应明文中的 E。一旦确定了这一对映射关系，就可以结合数学原理推算出密钥 a 和 b，从而破解整个密码。\n仿射密码的特点与应用 仿射密码作为古典密码的一种，具有其独特的特点，这些特点也决定了其在现代密码学中的地位和应用场景。\n特点 单表替换密码： 仿射密码属于单表替换密码的范畴，明文中的每一个特定字母，在加密过程中都会被唯一地替换为密文中的一个特定字母。这种一对一的映射关系是单表替换密码的显著特征。\n与凯撒密码的关系： 凯撒密码可以看作是仿射密码的一种特殊情况。当仿射密码的密钥 a=1 时，加密函数变为 E(x) = (1 * x + b) mod m = (x + b) mod m，这正是凯撒密码的加密函数。因此，凯撒密码是仿射密码的一个子集。\n应用 尽管仿射密码在现代通信中不再用于保护敏感信息，但它在密码学教育和入门领域仍有其价值：\n密码学教学： 仿射密码是理解古典密码原理、加密解密过程以及密钥概念的优秀教学工具。通过学习仿射密码，学生可以直观地了解替换密码的工作方式，以及模运算在密码学中的应用。\n频率分析演示： 仿射密码是演示频率分析攻击原理的理想示例。教师可以通过仿射密码的加密和解密过程，向学生展示如何利用语言的统计特性来破解简单的替换密码。\n编程实践： 实现仿射密码的加密和解密算法是初学者进行密码学编程实践的良好起点。这有助于培养编程技能，并加深对密码学算法的理解。\n历史研究： 作为古典密码的一部分，仿射密码在密码学发展史上占有一席之地。研究仿射密码有助于了解密码学从简单替换到复杂算法的演变过程。\n总而言之，仿射密码虽然在实际应用中已不再具备安全性，但其在密码学教育和历史研究中仍然发挥着重要的作用，为我们理解更复杂的加密技术提供了基础。\n总结 仿射密码作为古典密码学中的一个重要组成部分，以其简洁的数学原理和直观的加密过程，为我们理解密码学的基本概念提供了宝贵的视角。它通过线性函数 E(x) = (ax + b) mod m 将明文转换为密文，并通过其逆函数 D(y) = a^-1(y - b) mod m 进行解密。其中，密钥 a 与字母表大小 m 互质是确保可逆性的关键条件。\n尽管仿射密码在现代密码学中因其极小的密钥空间和易受频率分析攻击的弱点而不再具备实际的安全性，但它在密码学教育、历史研究以及编程实践中仍然扮演着不可或缺的角色。通过学习和实现仿射密码，我们不仅能够掌握古典密码的基本原理，还能为理解更复杂的加密算法和现代密码学奠定坚实的基础。\n从凯撒密码到仿射密码，再到更复杂的加密技术，密码学的发展史是一部不断演进的攻防史。每一次加密技术的进步都伴随着破解技术的突破，反之亦然。仿射密码正是这一演进过程中的一个重要里程碑，它以其独特的数学美感和历史意义，继续在密码学领域中闪耀着光芒。\n","date":"2025-08-12T17:15:00+08:00","permalink":"http://localhost:1313/post/programmingtechnology/classicalcryptography/affinecipher/","title":"仿射密码"},{"content":"什么是凯撒密码？ 凯撒密码是一种替换密码（Substitution Cipher），也被称为移位密码（Shift Cipher）。它的加密过程非常简单：将明文中的每一个字母，用字母表上固定距离的另一个字母来替换。\n这个“固定的距离”就是加密的密钥（Key）。\n例如，如果我们选择的密钥是 3，那么：\n字母 A 会被替换成字母表中向后移动 3 位的 D。 字母 B 会被替换成 E。 \u0026hellip; 字母 X 会被替换成 A（因为 X -\u0026gt; Y -\u0026gt; Z -\u0026gt; A，字母表是循环的）。 字母 Y 会被替换成 B。 字母 Z 会被替换成 C。 这个过程就像是将整个字母表向左平移了 3 位，形成了一个新的对应关系。\n加密示例 (密钥 = 3):\n明文 (Plaintext): HELLO WORLD 密文 (Ciphertext): KHOOR ZRUOG 凯撒密码的数学表示 尽管凯撒密码很简单，但我们依然可以用数学语言来精确地描述它。我们将字母表中的每个字母映射为一个数字（例如，A=0, B=1, \u0026hellip;, Z=25）。\n设：\nP 为明文字母对应的数字。 C 为密文字母对应的数字。 k 为密钥（位移量）。 那么，加密过程可以表示为： $$ C = (P + k) \\pmod{26} $$\n解密过程则是加密的逆运算，即向前移动 k 位： $$ P = (C - k) \\pmod{26} $$\n这里的 mod 26 (模26) 运算是关键，它完美地实现了字母表的循环。例如，当加密 X (23) 且密钥为 3 时： C = (23 + 3) mod 26 = 26 mod 26 = 0，对应的字母是 A。\n当解密 A (0) 且密钥为 3 时： P = (0 - 3) mod 26 = -3 mod 26。在模运算中，-3 和 23 是同余的，所以结果是 23，对应的字母是 X。\n如何破解凯撒密码？ 凯撒密码的安全性极低，因为它存在致命的弱点。主要有两种破解方法：\n1. 暴力破解 (Brute-force Attack) 由于英文字母只有 26 个，所以可能的密钥也只有 25 种（密钥为 0 或 26 没有意义，因为明文和密文会一样）。攻击者可以简单地将所有可能的密钥（从 1 到 25）全部尝试一遍，直到解密出的文本有意义为止。这个过程对于计算机来说是瞬时完成的。\n2. 频率分析 (Frequency Analysis) 在任何一种自然语言中，不同字母的出现频率是有统计规律的。例如，在英语中，字母 E 的出现频率最高，其次是 T, A, O 等。\n攻击者可以统计密文中每个字母的出现频率，找到出现次数最多的那个密文字母。它有极大的概率对应明文中的 E。一旦确定了这一对映射关系（比如密文 H 对应明文 E），就可以立即推算出密钥 k（从 E 到 H 的位移是 3），从而破解整个密码。\nC++ 代码实现 下面是一个完整的 C++ 程序，它实现了凯撒密码的加密和解密功能。代码结构清晰，并包含了详细的注释。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cctype\u0026gt; std::string caesarEncrypt(const std::string\u0026amp; text, int shift); std::string caesarDecrypt(const std::string\u0026amp; text, int shift); int main() { std::string message; int shift; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 凯撒密码加密/解密程序\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;=====================================\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;\\n请输入要处理的消息: \u0026#34;; std::getline(std::cin, message); std::cout \u0026lt;\u0026lt; \u0026#34;请输入移位量 (0-25 之间的整数): \u0026#34;; std::cin \u0026gt;\u0026gt; shift; shift = shift % 26; if (shift \u0026lt; 0) { shift += 26; } std::string encryptedMessage = caesarEncrypt(message, shift); std::cout \u0026lt;\u0026lt; \u0026#34;\\n加密后的密文是: \u0026#34; \u0026lt;\u0026lt; encryptedMessage \u0026lt;\u0026lt; std::endl; std::string decryptedMessage = caesarDecrypt(encryptedMessage, shift); std::cout \u0026lt;\u0026lt; \u0026#34;解密后的明文是: \u0026#34; \u0026lt;\u0026lt; decryptedMessage \u0026lt;\u0026lt; std::endl; return 0; } /** * @brief 对给定的文本进行凯撒加密 * @param text 要加密的明文 * @param shift 移位密钥 (0-25) * @return 加密后的密文 */ std::string caesarEncrypt(const std::string\u0026amp; text, int shift) { std::string result = \u0026#34;\u0026#34;; for (char c : text) { if (isalpha(c)) { char base = isupper(c) ? \u0026#39;A\u0026#39; : \u0026#39;a\u0026#39;; // Apply encryption formula: C = (P + k) % 26 result += static_cast\u0026lt;char\u0026gt;((c - base + shift) % 26 + base); } else { result += c; } } return result; } /** * @brief 对给定的文本进行凯撒解密 * @param text 要解密的密文 * @param shift 移位密钥 (0-25) * @return 解密后的明文 */ std::string caesarDecrypt(const std::string\u0026amp; text, int shift) { std::string result = \u0026#34;\u0026#34;; for (char c : text) { if (isalpha(c)) { char base = isupper(c) ? \u0026#39;A\u0026#39; : \u0026#39;a\u0026#39;; result += static_cast\u0026lt;char\u0026gt;((c - base - shift + 26) % 26 + base); } else { result += c; } } return result; } ","date":"2025-08-11T16:34:53+08:00","permalink":"http://localhost:1313/post/programmingtechnology/classicalcryptography/caesarcipher/","title":"凯撒密码"}]